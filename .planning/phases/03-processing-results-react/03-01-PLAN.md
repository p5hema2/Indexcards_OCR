---
phase: 03-processing-results-react
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/app/services/ws_manager.py
  - apps/backend/app/services/ocr_engine.py
  - apps/backend/app/api/api_v1/endpoints/batches.py
  - apps/backend/app/main.py
  - apps/frontend/vite.config.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/batches/{name}/results returns the checkpoint.json contents as a JSON array"
    - "POST /api/v1/batches/{name}/cancel sets a cancellation flag that stops OCR after the current image"
    - "POST /api/v1/batches/{name}/retry-image/{filename} moves a single failed file back and re-processes it"
    - "Batch images are servable via HTTP at /batches-static/{batch_name}/{filename}"
  artifacts:
    - path: "apps/backend/app/services/ws_manager.py"
      provides: "cancel_events dict and cancel_batch method using threading.Event"
      contains: "cancel_events"
    - path: "apps/backend/app/services/ocr_engine.py"
      provides: "cancel_event parameter in process_batch that breaks the processing loop"
      contains: "cancel_event"
    - path: "apps/backend/app/api/api_v1/endpoints/batches.py"
      provides: "Three new endpoints: GET results, POST cancel, POST retry-image"
      contains: "get_batch_results"
    - path: "apps/backend/app/main.py"
      provides: "StaticFiles mount for batch image serving"
      contains: "batches-static"
  key_links:
    - from: "apps/backend/app/api/api_v1/endpoints/batches.py"
      to: "apps/backend/app/services/ws_manager.py"
      via: "ws_manager.cancel_batch() call in cancel endpoint"
      pattern: "ws_manager\\.cancel_batch"
    - from: "apps/backend/app/services/ocr_engine.py"
      to: "apps/backend/app/services/ws_manager.py"
      via: "cancel_event passed from ws_manager into process_batch"
      pattern: "cancel_event.*is_set"
---

<objective>
Add the missing backend endpoints and infrastructure required by the Phase 3 frontend: a results-read endpoint (GET results from checkpoint.json), a cancellation endpoint (POST cancel with cooperative threading.Event), a single-image retry endpoint, and a StaticFiles mount for serving batch images as thumbnails.

Purpose: The frontend Processing and Results steps cannot function without these backend pieces. This plan creates all backend prerequisites first so frontend plans can develop against working APIs.
Output: Four new backend capabilities ready for frontend consumption; Vite proxy updated for WebSocket paths.
</objective>

<execution_context>
@/Users/martinhess/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martinhess/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-processing-results-react/03-RESEARCH.md
@apps/backend/app/services/ws_manager.py
@apps/backend/app/services/ocr_engine.py
@apps/backend/app/api/api_v1/endpoints/batches.py
@apps/backend/app/main.py
@apps/backend/app/models/schemas.py
@apps/backend/app/core/config.py
@apps/frontend/vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cooperative cancellation to ws_manager and ocr_engine</name>
  <files>
    apps/backend/app/services/ws_manager.py
    apps/backend/app/services/ocr_engine.py
  </files>
  <action>
**ws_manager.py:**
1. Add `import threading` at the top.
2. Add `self.cancel_events: Dict[str, threading.Event] = {}` to `ConnectionManager.__init__`.
3. Add method `get_or_create_cancel_event(self, batch_id: str) -> threading.Event` that lazy-creates and returns the event.
4. Add method `cancel_batch(self, batch_id: str)` that calls `.set()` on the event if it exists.
5. Add method `clear_cancel_event(self, batch_id: str)` that removes and optionally resets the event (for cleanup after batch completion).

Use `threading.Event` (NOT `asyncio.Event`) per research recommendation -- `asyncio.Event` is not safe to check from `asyncio.to_thread` worker threads. `threading.Event.is_set()` is explicitly thread-safe.

**ocr_engine.py:**
1. Add `cancel_event: Optional[threading.Event] = None` parameter to `process_batch()` method signature (after `resume`).
2. Import `threading` at the top.
3. In `_run_batch()` inner function, after each `fut.result()` call and checkpoint save, add a cancel check:
   ```python
   if cancel_event and cancel_event.is_set():
       logger.info(f"Batch {batch_name} cancelled by user after {i} images")
       break
   ```
4. This provides per-image cancellation granularity. One image may complete after cancel is pressed -- this is expected and matches the "partial results are kept" requirement since checkpoint is saved before the cancel check.
  </action>
  <verify>
Run `cd /Users/martinhess/workspace/hack-the-heritage/Indexcards_OCR/apps/backend && uv run python -c "from app.services.ws_manager import ws_manager; e = ws_manager.get_or_create_cancel_event('test'); assert not e.is_set(); ws_manager.cancel_batch('test'); assert e.is_set(); print('OK')"` to confirm cancel_event works.
Run `cd /Users/martinhess/workspace/hack-the-heritage/Indexcards_OCR/apps/backend && uv run python -c "import inspect; from app.services.ocr_engine import OcrEngine; sig = inspect.signature(OcrEngine.process_batch); assert 'cancel_event' in sig.parameters; print('OK')"` to confirm parameter exists.
  </verify>
  <done>
ws_manager has cancel_events dict with get_or_create_cancel_event, cancel_batch, and clear_cancel_event methods using threading.Event. ocr_engine.process_batch accepts cancel_event parameter and checks it between image completions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add results, cancel, retry-image endpoints and StaticFiles mount</name>
  <files>
    apps/backend/app/api/api_v1/endpoints/batches.py
    apps/backend/app/main.py
    apps/frontend/vite.config.ts
  </files>
  <action>
**batches.py -- Add three new endpoints:**

1. `GET /{batch_name}/results`:
   - Read `checkpoint.json` from the batch directory using `batch_manager.get_batch_path(batch_name)`.
   - If batch path doesn't exist, raise 404.
   - If `checkpoint.json` doesn't exist, return empty list `[]`.
   - Parse and return the JSON array directly. No Pydantic validation needed (the data may have extra fields like `has_komponist` from the OCR engine).
   - Add `import json` if not already present (it is).

2. `POST /{batch_name}/cancel`:
   - Import `ws_manager` (already imported).
   - Call `ws_manager.cancel_batch(batch_name)`.
   - Return `{"message": "Cancel requested", "batch_name": batch_name}`.
   - No 404 check needed -- cancelling a non-running batch is a no-op.

3. `POST /{batch_name}/retry-image/{filename}`:
   - Get batch path, check `_errors/{filename}` exists (404 if not).
   - Move the file from `_errors/` back to the batch directory using `shutil.move`.
   - Read `checkpoint.json`, remove the entry for that filename (so it gets re-processed), write it back.
   - **Clear any stale cancel event** before starting the retry: call `ws_manager.clear_cancel_event(batch_name)`. Without this, a previous cancellation's set event would cause the retry to abort immediately.
   - Call `background_tasks.add_task(run_ocr_task, batch_name)` to start processing.
   - Return `{"message": f"Retry started for {filename}", "batch_name": batch_name}`.

4. **Update `run_ocr_task`** to pass `cancel_event` to `ocr_engine.process_batch`:
   - At the top of `run_ocr_task`, get or create the cancel event: `cancel_event = ws_manager.get_or_create_cancel_event(batch_name)`.
   - **Immediately clear it** to prevent stale cancellation from a previous run: `cancel_event.clear()`. This ensures a fresh state regardless of which endpoint invoked the task.
   - Pass `cancel_event=cancel_event` to `ocr_engine.process_batch(...)`.
   - After processing completes (or fails), call `ws_manager.clear_cancel_event(batch_name)` to clean up (remove from dict).
   - Add a cancelled status: after `process_batch` returns, check `if cancel_event.is_set():` and set `last_state.status = "cancelled"` instead of `"completed"`.

5. **Update the existing `retry_batch` endpoint** (POST `/{batch_name}/retry`): Add `ws_manager.clear_cancel_event(batch_name)` before `background_tasks.add_task(...)`, same as the retry-image endpoint, so that bulk retries also start with a fresh cancel state.

**main.py -- Add StaticFiles mount:**
1. Add `from fastapi.staticfiles import StaticFiles` and `from pathlib import Path`.
2. After `app.include_router(...)`, add:
   ```python
   batches_dir = Path(settings.BATCHES_DIR)
   batches_dir.mkdir(parents=True, exist_ok=True)
   app.mount("/batches-static", StaticFiles(directory=str(batches_dir)), name="batches-static")
   ```
3. The mount must come AFTER `include_router` so API routes take priority. StaticFiles is a fallback.

**vite.config.ts -- Ensure WebSocket proxy works:**
The current proxy config has `/api` -> `http://localhost:8000` which covers REST endpoints. It also has `/ws` -> `ws://localhost:8000` but the actual WS path is `/api/v1/ws/task/{batch_id}` which is already covered by the `/api` proxy. However, the `/api` proxy does NOT have `ws: true` set, which means WebSocket upgrade requests on `/api/v1/ws/...` will fail.

Fix: Add `ws: true` to the `/api` proxy entry. The separate `/ws` proxy entry can stay for backward compatibility or be removed (it matches no actual routes currently).

Update the proxy config:
```typescript
proxy: {
  '/api': {
    target: 'http://localhost:8000',
    changeOrigin: true,
    ws: true,
  },
  '/batches-static': {
    target: 'http://localhost:8000',
    changeOrigin: true,
  },
},
```
Also add a proxy for `/batches-static` so thumbnail images route to the backend. Remove the old `/ws` proxy entry since it matches no real routes.
  </action>
  <verify>
Start the backend: `cd /Users/martinhess/workspace/hack-the-heritage/Indexcards_OCR/apps/backend && uv run uvicorn app.main:app --reload --port 8000 &`
Test results endpoint: `curl -s http://localhost:8000/api/v1/batches/nonexistent/results` should return 404.
Test cancel endpoint: `curl -s -X POST http://localhost:8000/api/v1/batches/test/cancel` should return JSON with "Cancel requested".
Verify StaticFiles mount: `curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/batches-static/` should return 404 or 200 (not 500).
Stop the backend after verification.
Verify Vite config compiles: `cd /Users/martinhess/workspace/hack-the-heritage/Indexcards_OCR/apps/frontend && npx tsc --noEmit vite.config.ts` or just check the file syntax.
  </verify>
  <done>
Three new endpoints (GET results, POST cancel, POST retry-image) are functional. StaticFiles serves batch images at /batches-static/. run_ocr_task passes cancel_event and detects cancellation. Vite proxy has ws:true for /api and a /batches-static proxy entry.
  </done>
</task>

</tasks>

<verification>
1. Backend imports cleanly: `cd apps/backend && uv run python -c "from app.main import app; print('OK')"`
2. All three new endpoints are registered: `cd apps/backend && uv run python -c "from app.main import app; routes = [r.path for r in app.routes]; print([r for r in routes if 'results' in r or 'cancel' in r or 'retry-image' in r])"` shows the three new paths.
3. Frontend typecheck passes: `cd apps/frontend && npx tsc --noEmit`
4. Cancel event lifecycle: create -> is_set false -> cancel -> is_set true -> clear -> removed.
</verification>

<success_criteria>
- GET /api/v1/batches/{name}/results returns checkpoint data as JSON array (empty array if no checkpoint)
- POST /api/v1/batches/{name}/cancel sets a threading.Event that stops the OCR loop
- POST /api/v1/batches/{name}/retry-image/{filename} moves file from _errors, removes checkpoint entry, and restarts processing
- Images in data/batches/ are servable at /batches-static/{batch_name}/{filename}
- run_ocr_task integrates cancel_event into the process_batch call
- Vite dev server proxies both REST and WebSocket traffic to backend
</success_criteria>

<output>
After completion, create `.planning/phases/03-processing-results-react/03-01-SUMMARY.md`
</output>
