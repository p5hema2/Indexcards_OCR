---
phase: 03-processing-results-react
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - apps/frontend/package.json
  - apps/frontend/src/features/results/ResultsStep.tsx
  - apps/frontend/src/features/results/SummaryBanner.tsx
  - apps/frontend/src/features/results/ResultsTable.tsx
  - apps/frontend/src/features/results/ThumbnailCell.tsx
  - apps/frontend/src/features/results/useResultsExport.ts
  - apps/frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "On entering the results step, data is fetched from GET /batches/{name}/results and displayed in a sortable data table"
    - "Each row shows a thumbnail, filename, status, extracted fields, and duration"
    - "Clicking a thumbnail opens a full-size lightbox overlay for verifying OCR accuracy"
    - "Clicking an extracted field cell makes it editable; edits are tracked in editedData for audit trail"
    - "Table columns are sortable by clicking headers"
    - "Failed images appear inline with red status indicator and per-row Retry button"
    - "A Retry All Failed button at the top retries all failed images"
    - "Download CSV produces UTF-8 with BOM file containing both OCR and edited values"
    - "Download JSON produces a structured export with audit trail"
    - "Summary banner shows total processed, success count, error count, total duration, and batch name"
  artifacts:
    - path: "apps/frontend/src/features/results/ResultsStep.tsx"
      provides: "Main results step component that fetches data and orchestrates sub-components"
      contains: "ResultsStep"
    - path: "apps/frontend/src/features/results/SummaryBanner.tsx"
      provides: "Stats banner with download buttons"
      contains: "SummaryBanner"
    - path: "apps/frontend/src/features/results/ResultsTable.tsx"
      provides: "TanStack table with sortable columns, editable cells, retry actions"
      contains: "ResultsTable"
    - path: "apps/frontend/src/features/results/ThumbnailCell.tsx"
      provides: "Thumbnail image with lightbox trigger"
      contains: "ThumbnailCell"
    - path: "apps/frontend/src/features/results/useResultsExport.ts"
      provides: "CSV and JSON generation with UTF-8 BOM and audit trail"
      contains: "useResultsExport"
  key_links:
    - from: "apps/frontend/src/features/results/ResultsStep.tsx"
      to: "/api/v1/batches/{name}/results"
      via: "fetchResults query on mount"
      pattern: "fetchResults|useResultsQuery"
    - from: "apps/frontend/src/features/results/ResultsTable.tsx"
      to: "apps/frontend/src/store/wizardStore.ts"
      via: "updateResultCell action for inline editing"
      pattern: "updateResultCell"
    - from: "apps/frontend/src/features/results/ThumbnailCell.tsx"
      to: "/batches-static/{batch_name}/{filename}"
      via: "img src URL"
      pattern: "batches-static"
    - from: "apps/frontend/src/features/results/useResultsExport.ts"
      to: "Blob + anchor download"
      via: "Client-side CSV/JSON generation"
      pattern: "\\\\uFEFF|createObjectURL"
    - from: "apps/frontend/src/App.tsx"
      to: "apps/frontend/src/features/results/ResultsStep.tsx"
      via: "Import and render in step switch"
      pattern: "ResultsStep"
---

<objective>
Build the Results wizard step: install table and lightbox dependencies, create the sortable/editable data table with TanStack React Table, summary banner with stats and download buttons, thumbnail cells with lightbox overlay, inline editing with audit trail, retry capability, and CSV/JSON export.

Purpose: The results table is the primary deliverable view where museum staff verify and correct OCR results before exporting to their collection management system. This is the most feature-dense step in the entire application.
Output: A fully functional Results step with editable table, thumbnails, lightbox, retry, and export capabilities.
</objective>

<execution_context>
@/Users/martinhess/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martinhess/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-processing-results-react/03-RESEARCH.md
@.planning/phases/03-processing-results-react/03-02-SUMMARY.md
@apps/frontend/src/store/wizardStore.ts
@apps/frontend/src/api/batchesApi.ts
@apps/frontend/src/App.tsx
@apps/frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and build ResultsTable with TanStack React Table</name>
  <files>
    apps/frontend/package.json
    apps/frontend/src/features/results/ResultsTable.tsx
    apps/frontend/src/features/results/ThumbnailCell.tsx
    apps/frontend/src/features/results/SummaryBanner.tsx
  </files>
  <action>
**Install dependencies:**
```bash
cd apps/frontend && npm install @tanstack/react-table yet-another-react-lightbox
```

**ResultsTable.tsx -- Sortable, editable data table using @tanstack/react-table v8:**

Props: `results: ResultRow[], fields: string[], batchName: string, onRetryImage: (filename: string) => void, isProcessing: boolean`.

1. Import from `@tanstack/react-table`: `useReactTable`, `getCoreRowModel`, `getSortedRowModel`, `flexRender`, `createColumnHelper`, `SortingState`.

2. Build columns dynamically:
   - **Thumbnail column** (display): renders `<ThumbnailCell>` with `batchName` and `row.filename`.
   - **Filename column** (accessor): `row.filename`, sortable.
   - **Status column** (accessor): `row.status`, sortable. Render with color coding:
     - Use a lookup map (NOT string concatenation -- Tailwind JIT Pitfall 5 from research):
       ```typescript
       const statusStyles = {
         success: 'text-green-700 bg-green-50',
         failed: 'text-red-600 bg-red-50',
       } as const;
       ```
   - **Dynamic field columns**: For each field in the `fields` array, create a display column that renders an `EditableCell` sub-component. The cell shows `row.editedData[field] ?? row.data[field] ?? ''`. On edit, call `updateResultCell(filename, field, newValue)` from the Zustand store.
   - **Duration column** (accessor): `row.duration`, sortable, formatted as `${duration.toFixed(1)}s`.
   - **Actions column** (display): For failed rows, show a "Retry" button. Disable if `isProcessing` is true. On click, call `onRetryImage(filename)`.
   - **Error column** (display): Only visible for failed rows -- shows `row.error` text in red/italic.

3. Implement `EditableCell` as an inline component or separate sub-component:
   - Default: display mode showing the text value.
   - On click: switch to an `<input>` with the current value, auto-focus.
   - On blur or Enter: commit the value via `updateResultCell` and switch back to display mode.
   - Visual indicator if edited: show a small dot or different text color if `editedData[field]` differs from `data[field]`.
   - Style the input: `bg-transparent border-b border-archive-sepia/50 focus:outline-none font-serif` to match the parchment aesthetic.

4. Table setup:
   ```typescript
   const [sorting, setSorting] = useState<SortingState>([]);
   const table = useReactTable({
     data: results,
     columns,
     state: { sorting },
     onSortingChange: setSorting,
     getCoreRowModel: getCoreRowModel(),
     getSortedRowModel: getSortedRowModel(),
   });
   ```

5. Render the table with parchment styling:
   - `<table>` with `w-full border-collapse`.
   - Headers: `text-xs uppercase tracking-widest text-archive-ink/40 font-semibold cursor-pointer` with sort indicators (`↑`/`↓`). Use `header.column.getToggleSortingHandler()` for click.
   - Rows: alternating `bg-parchment-light/20` and `bg-transparent`. Failed rows get `bg-red-50/20`.
   - Cells: `px-4 py-2 text-sm font-serif`.
   - Border: `border-b border-parchment-dark/20` between rows.

**ThumbnailCell.tsx -- Thumbnail with lightbox:**

Props: `batchName: string, filename: string`.

1. Import `Lightbox` from `yet-another-react-lightbox` and its CSS: `import 'yet-another-react-lightbox/styles.css'`.
2. Compute image URL: `/batches-static/${batchName}/${filename}`.
3. Render:
   - A small `<img>` with `w-16 h-12 object-cover rounded cursor-pointer border border-parchment-dark hover:opacity-80 transition-opacity`.
   - On click, open the lightbox.
   - `<Lightbox open={open} close={() => setOpen(false)} slides={[{ src: imageUrl }]} />`
4. Handle image load errors gracefully: if the image fails to load, show a placeholder icon (use `ImageOff` from lucide-react).

**SummaryBanner.tsx -- Stats and download buttons:**

Props: `results: ResultRow[], batchName: string, totalDuration: number, onDownloadCSV: () => void, onDownloadJSON: () => void, onRetryAllFailed: () => void, failedCount: number, isProcessing: boolean`.

Display a horizontal banner with the parchment aesthetic:
- Left side stats: `{results.length} Processed` | `{successCount} Success` | `{failedCount} Errors` | `{totalDuration.toFixed(1)}s Total` | batch name.
- Right side buttons:
  - "Retry All Failed" button (visible only if failedCount > 0, disabled if isProcessing): icon `RotateCcw` from lucide-react, styled as secondary/outline.
  - "Download CSV" button: icon `FileSpreadsheet` from lucide-react.
  - "Download JSON" button: icon `FileJson` from lucide-react.
- Style: `bg-parchment-light/30 border border-parchment-dark/50 rounded-lg p-4 parchment-shadow`.
- Stat numbers in `font-mono text-archive-sepia font-bold`, labels in `text-xs uppercase tracking-widest text-archive-ink/40`.
  </action>
  <verify>
Run `cd /Users/martinhess/workspace/hack-the-heritage/Indexcards_OCR/apps/frontend && npx tsc --noEmit` to verify no TypeScript errors.
Verify deps installed: `cd apps/frontend && node -e "require('@tanstack/react-table'); require('yet-another-react-lightbox'); console.log('OK')"`.
  </verify>
  <done>
@tanstack/react-table and yet-another-react-lightbox installed. ResultsTable renders a sortable, editable table with dynamic field columns, status coloring, retry buttons, and inline editing. ThumbnailCell shows image thumbnails with YARL lightbox overlay. SummaryBanner displays stats and download/retry buttons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create export hook, ResultsStep, and wire into App.tsx</name>
  <files>
    apps/frontend/src/features/results/useResultsExport.ts
    apps/frontend/src/features/results/ResultsStep.tsx
    apps/frontend/src/App.tsx
  </files>
  <action>
**useResultsExport.ts -- CSV and JSON generation with audit trail:**

Export a hook: `useResultsExport(results: ResultRow[], fields: string[], batchName: string)` that returns `{ downloadCSV, downloadJSON }`.

1. `downloadCSV()`:
   - Build headers array: `['File', 'Status', 'Error', 'Duration(s)', ...fields.flatMap(f => [\`${f}_ocr\`, \`${f}_edited\`])]`.
   - For each field, include BOTH the original OCR value (`data[field]`) and the edited value (`editedData[field]`). If not edited, the `_edited` column is empty. This provides the audit trail museums need.
   - Build rows: map each ResultRow to an array matching the headers.
   - CSV encoding: quote all cells with double-quotes, escape internal quotes by doubling (`""`).
   - Join rows with `\r\n` (CRLF for Windows/Excel compatibility).
   - **UTF-8 BOM**: Prepend `\uFEFF` to the CSV string before creating the Blob.
   - Create Blob with `type: 'text/csv;charset=utf-8'`.
   - Trigger download via a temporary `<a>` element with `download` attribute set to `${batchName}_results.csv`.
   - Clean up with `URL.revokeObjectURL`.

2. `downloadJSON()`:
   - Build a structured JSON payload:
     ```typescript
     results.map(row => ({
       filename: row.filename,
       status: row.status,
       error: row.error ?? null,
       duration: row.duration,
       fields: Object.fromEntries(
         fields.map(f => [f, {
           ocr: row.data[f] ?? '',
           ...(row.editedData[f] !== undefined ? { edited: row.editedData[f] } : {}),
         }])
       ),
     }))
     ```
   - Create Blob with `type: 'application/json'` and `JSON.stringify(payload, null, 2)`.
   - Trigger download as `${batchName}_results.json`.

3. Both functions use the native Blob + anchor pattern (no library needed per research).

**ResultsStep.tsx -- Main results step component:**

This is the primary deliverable view.

1. **On mount**, fetch results from the backend:
   - Use the `useResultsQuery(batchName)` hook from batchesApi.ts (or call `fetchResults` directly).
   - Transform the raw `ExtractionResult[]` from the API into `ResultRow[]`:
     ```typescript
     const rows: ResultRow[] = rawResults.map(r => ({
       filename: r.filename,
       status: r.success ? 'success' : 'failed',
       error: r.error ?? undefined,
       data: r.data ?? {},
       editedData: {},
       duration: r.duration,
     }));
     ```
   - Call `setResults(rows)` to populate the Zustand store.
   - IMPORTANT: Always hydrate from the backend endpoint, never from WS messages alone (research anti-pattern: "Reading results from WS messages alone" -- WS stream can have gaps from reconnects).

2. **Merge existing edits**: If the store already has `results` with `editedData` entries (from a previous view of this batch), merge the edits over the fresh backend data. This preserves user corrections across page refreshes within a session.

3. **Get fields** from the Zustand store (`fields` array, map to labels).

4. **Retry handlers**:
   - `handleRetryImage(filename)`: call `retryImage(batchName, filename)` from batchesApi. Set `isProcessing(true)`. After the retry starts, the user should be sent back to the processing step (`setStep('processing')`) since a new WS stream will begin.
   - `handleRetryAllFailed()`: call the existing `useStartBatchMutation` for the retry endpoint (`POST /batches/{name}/retry`). Set `isProcessing(true)` and navigate to processing step.

5. **Compute summary stats**:
   - `successCount`: results where status === 'success'.
   - `failedCount`: results where status === 'failed'.
   - `totalDuration`: sum of all `duration` values.

6. **Layout** (vertical stack, parchment aesthetic):
   - Header: "Archival Results" with batch name subtitle.
   - `<SummaryBanner>` with stats and download buttons.
   - `<ResultsTable>` with the full data.
   - Bottom: "Start New Batch" button that calls `resetWizard()` and navigates to upload.

7. **Loading state**: While `useResultsQuery` is loading, show a centered spinner with "Loading archival results..." message.

8. **Empty state**: If results array is empty after loading, show "No results found for this batch."

**App.tsx -- Wire ResultsStep:**

1. Import `ResultsStep` from `./features/results/ResultsStep`.
2. Replace the placeholder `case 'results':` div with `<ResultsStep />`.
  </action>
  <verify>
Run `cd /Users/martinhess/workspace/hack-the-heritage/Indexcards_OCR/apps/frontend && npx tsc --noEmit` to verify no TypeScript errors.
Verify all new files exist: `ls apps/frontend/src/features/results/` should show 5 files.
Verify App.tsx imports both ProcessingStep and ResultsStep: `grep -E 'ProcessingStep|ResultsStep' apps/frontend/src/App.tsx`.
  </verify>
  <done>
ResultsStep fetches results from backend, displays SummaryBanner with stats and CSV/JSON download buttons, renders a sortable/editable ResultsTable with thumbnails and lightbox, supports per-image and bulk retry, and provides a "Start New Batch" action. useResultsExport generates CSV with UTF-8 BOM and JSON with audit trail. App.tsx renders ResultsStep for the results wizard step.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/frontend && npx tsc --noEmit` passes with zero errors.
2. All feature files exist: `ls apps/frontend/src/features/results/` shows ResultsStep.tsx, SummaryBanner.tsx, ResultsTable.tsx, ThumbnailCell.tsx, useResultsExport.ts.
3. Dependencies installed: `npm ls @tanstack/react-table yet-another-react-lightbox` shows both.
4. App.tsx has no placeholder divs remaining for processing/results steps.
5. CSV export includes BOM: grep for `\uFEFF` in useResultsExport.ts.
6. Lightbox CSS imported: grep for `yet-another-react-lightbox/styles.css` in ThumbnailCell.tsx.
</verification>

<success_criteria>
- ResultsStep fetches from GET /batches/{name}/results and displays in sortable table
- Each column is sortable by clicking the header
- Clicking a field cell activates inline editing; edits tracked in editedData
- Thumbnails load from /batches-static/ and open in YARL lightbox
- Failed rows show red status indicator with per-row Retry button
- Retry All Failed button retries all failed images and navigates to processing
- Download CSV produces UTF-8 BOM file with both _ocr and _edited columns per field
- Download JSON includes audit trail (ocr + edited per field)
- Summary banner shows total, success, error counts, duration, batch name
- No placeholder divs remain in App.tsx for processing or results steps
</success_criteria>

<output>
After completion, create `.planning/phases/03-processing-results-react/03-03-SUMMARY.md`
</output>
