---
phase: 03-processing-results-react
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/frontend/src/store/wizardStore.ts
  - apps/frontend/src/api/batchesApi.ts
  - apps/frontend/src/features/processing/useProcessingWebSocket.ts
  - apps/frontend/src/features/processing/ProcessingStep.tsx
  - apps/frontend/src/features/processing/ProgressBar.tsx
  - apps/frontend/src/features/processing/LiveFeed.tsx
  - apps/frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "When the wizard enters the processing step, a WebSocket connects to the batch and progress updates appear in real time"
    - "The progress bar shows percentage, X/Y count, current image name, and estimated time remaining"
    - "A live feed below the progress bar shows each completed image's extracted data as it streams in"
    - "The cancel button sends POST /cancel and keeps partial results"
    - "After 3 consecutive failures, processing stops and an error screen appears with troubleshooting hints"
    - "After completion, the wizard auto-navigates to results step after a brief delay"
  artifacts:
    - path: "apps/frontend/src/store/wizardStore.ts"
      provides: "processingState slice with consecutiveFailures, liveFeedItems, lastProgress, isCancelled; results array; actions for appendLiveFeedItem, setLastProgress, setResults, updateResultCell, resetProcessing"
      contains: "processingState"
    - path: "apps/frontend/src/features/processing/useProcessingWebSocket.ts"
      provides: "Custom WebSocket hook using native WebSocket API, connects to /api/v1/ws/task/{batchId}"
      contains: "useProcessingWebSocket"
    - path: "apps/frontend/src/features/processing/ProcessingStep.tsx"
      provides: "Main step component orchestrating progress display, live feed, cancel, catastrophic failure, and auto-navigate"
      contains: "ProcessingStep"
    - path: "apps/frontend/src/features/processing/ProgressBar.tsx"
      provides: "Animated progress bar with percentage, X/Y count, ETA"
      contains: "ProgressBar"
    - path: "apps/frontend/src/features/processing/LiveFeed.tsx"
      provides: "Scrolling log of completed images with extracted data"
      contains: "LiveFeed"
    - path: "apps/frontend/src/api/batchesApi.ts"
      provides: "cancelBatch, fetchResults, retryImage, retryBatch API functions and corresponding TanStack Query hooks"
      contains: "useRetryBatchMutation"
  key_links:
    - from: "apps/frontend/src/features/processing/ProcessingStep.tsx"
      to: "apps/frontend/src/features/processing/useProcessingWebSocket.ts"
      via: "useProcessingWebSocket(batchId) hook call"
      pattern: "useProcessingWebSocket"
    - from: "apps/frontend/src/features/processing/ProcessingStep.tsx"
      to: "apps/frontend/src/store/wizardStore.ts"
      via: "Zustand actions for processing state and step transition"
      pattern: "useWizardStore"
    - from: "apps/frontend/src/features/processing/useProcessingWebSocket.ts"
      to: "/api/v1/ws/task/{batchId}"
      via: "Native WebSocket connection"
      pattern: "new WebSocket"
    - from: "apps/frontend/src/App.tsx"
      to: "apps/frontend/src/features/processing/ProcessingStep.tsx"
      via: "Import and render in step switch"
      pattern: "ProcessingStep"
---

<objective>
Build the Processing wizard step: extend the Zustand store with processing/results state, create a custom WebSocket hook, and implement the ProcessingStep with ProgressBar, LiveFeed, cancel support, catastrophic failure detection, and auto-navigation to results.

Purpose: This is the real-time experience users see while their index cards are being OCR-processed. It must feel responsive and informative -- progress bar, live feed of extracted data, and graceful handling of cancellation and failures.
Output: A fully functional Processing step that connects to the backend WebSocket, displays real-time progress, and transitions to the Results step on completion.
</objective>

<execution_context>
@/Users/martinhess/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martinhess/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-processing-results-react/03-RESEARCH.md
@.planning/phases/03-processing-results-react/03-01-SUMMARY.md
@apps/frontend/src/store/wizardStore.ts
@apps/frontend/src/api/batchesApi.ts
@apps/frontend/src/App.tsx
@apps/frontend/src/features/configure/ConfigureStep.tsx
@apps/frontend/src/components/Footer.tsx
@apps/backend/app/models/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Zustand store and add API functions</name>
  <files>
    apps/frontend/src/store/wizardStore.ts
    apps/frontend/src/api/batchesApi.ts
  </files>
  <action>
**wizardStore.ts -- Add processing/results state slices:**

1. Define new interfaces above `WizardState`:

```typescript
export interface ExtractionResult {
  filename: string;
  batch: string;
  success: boolean;
  data: Record<string, string> | null;
  error?: string | null;
  duration: number;
}

export interface BatchProgress {
  batch_name: string;
  current: number;
  total: number;
  percentage: number;
  eta_seconds: number | null;
  last_result: ExtractionResult | null;
  status: 'running' | 'completed' | 'failed' | 'retrying' | 'cancelled';
}

export interface ResultRow {
  filename: string;
  status: 'success' | 'failed';
  error?: string;
  data: Record<string, string>;
  editedData: Record<string, string>;
  duration: number;
}

export interface ProcessingState {
  consecutiveFailures: number;
  liveFeedItems: ExtractionResult[];
  lastProgress: BatchProgress | null;
  isCancelled: boolean;
  isProcessing: boolean;
}
```

2. Extend `WizardState` interface with:
   - `processingState: ProcessingState`
   - `results: ResultRow[]`
   - `appendLiveFeedItem: (item: ExtractionResult) => void`
   - `setLastProgress: (p: BatchProgress) => void`
   - `incrementConsecutiveFailures: () => void`
   - `resetConsecutiveFailures: () => void`
   - `setCancelled: (cancelled: boolean) => void`
   - `setIsProcessing: (processing: boolean) => void`
   - `setResults: (rows: ResultRow[]) => void`
   - `updateResultCell: (filename: string, field: string, value: string) => void`
   - `resetProcessing: () => void`

3. Add `initialProcessingState` constant:
```typescript
const initialProcessingState: ProcessingState = {
  consecutiveFailures: 0,
  liveFeedItems: [],
  lastProgress: null,
  isCancelled: false,
  isProcessing: false,
};
```

4. Add to `initialState`: `processingState: initialProcessingState, results: []`.

5. Implement all new actions in the store creator. Key patterns:
   - `appendLiveFeedItem`: append to `processingState.liveFeedItems` array (use spread or immer-style).
   - `setLastProgress`: set `processingState.lastProgress`.
   - `incrementConsecutiveFailures`: increment `processingState.consecutiveFailures`.
   - `resetConsecutiveFailures`: set `processingState.consecutiveFailures` to 0.
   - `updateResultCell`: find the ResultRow by filename, add/update the field in `editedData`.
   - `resetProcessing`: reset `processingState` to `initialProcessingState` and `results` to `[]`.

6. **Critical: Add `partialize` to persist middleware** to exclude `results` and `processingState` from localStorage:
```typescript
persist(
  (set) => ({ ... }),
  {
    name: 'wizard-storage',
    partialize: (state) => ({
      step: state.step,
      files: state.files,
      fields: state.fields,
      sessionId: state.sessionId,
      batchId: state.batchId,
    }),
  }
)
```
This prevents performance issues from serializing large results arrays on every cell edit (Pitfall 6 from research).

**batchesApi.ts -- Add cancel and results API functions:**

1. Add `cancelBatch` function:
```typescript
export const cancelBatch = async (batchName: string): Promise<{ message: string; batch_name: string }> => {
  const response = await axios.post<{ message: string; batch_name: string }>(`/api/v1/batches/${batchName}/cancel`);
  return response.data;
};
```

2. Add `fetchResults` function:
```typescript
export const fetchResults = async (batchName: string): Promise<ExtractionResult[]> => {
  const response = await axios.get<ExtractionResult[]>(`/api/v1/batches/${batchName}/results`);
  return response.data;
};
```
Import `ExtractionResult` from the wizardStore (or define inline -- prefer importing from store since it's the canonical type).

3. Add `retryImage` function:
```typescript
export const retryImage = async (batchName: string, filename: string): Promise<{ message: string }> => {
  const response = await axios.post<{ message: string }>(`/api/v1/batches/${batchName}/retry-image/${filename}`);
  return response.data;
};
```

4. Add `retryBatch` function for the bulk-retry endpoint:
```typescript
export const retryBatch = async (batchName: string): Promise<{ message: string; batch_name: string }> => {
  const response = await axios.post<{ message: string; batch_name: string }>(`/api/v1/batches/${batchName}/retry`);
  return response.data;
};
```

5. Add corresponding TanStack Query mutation hooks: `useCancelBatchMutation`, `useRetryImageMutation`, and `useRetryBatchMutation` (calls `retryBatch` -- POST `/retry`, distinct from `useStartBatchMutation` which calls POST `/start`). Add a `useResultsQuery` using `useQuery` that calls `fetchResults(batchName)` with `enabled: !!batchName`.
  </action>
  <verify>
Run `cd /Users/martinhess/workspace/hack-the-heritage/Indexcards_OCR/apps/frontend && npx tsc --noEmit` to verify no TypeScript errors.
  </verify>
  <done>
Zustand store has processingState and results slices with all actions. Persist middleware uses partialize to exclude heavy data. batchesApi has cancelBatch, fetchResults, retryImage functions plus TanStack Query hooks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket hook, ProcessingStep, ProgressBar, and LiveFeed components</name>
  <files>
    apps/frontend/src/features/processing/useProcessingWebSocket.ts
    apps/frontend/src/features/processing/ProcessingStep.tsx
    apps/frontend/src/features/processing/ProgressBar.tsx
    apps/frontend/src/features/processing/LiveFeed.tsx
    apps/frontend/src/App.tsx
  </files>
  <action>
**useProcessingWebSocket.ts -- Custom WebSocket hook (~30 lines):**

Use the NATIVE WebSocket API (do NOT install react-use-websocket -- it has a React 19 flushSync incompatibility per research Pitfall 1).

```typescript
import { useEffect, useRef, useCallback } from 'react';
import type { BatchProgress } from '../../store/wizardStore';

export function useProcessingWebSocket(
  batchId: string | null,
  onMessage: (progress: BatchProgress) => void
) {
  const wsRef = useRef<WebSocket | null>(null);
  const onMessageRef = useRef(onMessage);
  onMessageRef.current = onMessage;

  useEffect(() => {
    if (!batchId) return;

    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${location.host}/api/v1/ws/task/${batchId}`;
    const ws = new WebSocket(wsUrl);
    wsRef.current = ws;

    ws.onmessage = (event) => {
      try {
        const data: BatchProgress = JSON.parse(event.data);
        onMessageRef.current(data);
      } catch {
        console.error('WS parse error', event.data);
      }
    };

    ws.onclose = () => {
      // Single reconnect after 1s -- backend re-sends last state on reconnect
      // No need for exponential backoff (local/LAN use only)
      setTimeout(() => {
        if (wsRef.current === ws) {
          // Only reconnect if we haven't been cleaned up
          const newWs = new WebSocket(wsUrl);
          newWs.onmessage = ws.onmessage;
          newWs.onclose = ws.onclose;
          wsRef.current = newWs;
        }
      }, 1000);
    };

    return () => {
      const ref = wsRef.current;
      wsRef.current = null; // Signal cleanup to prevent reconnect
      ref?.close();
    };
  }, [batchId]);

  const close = useCallback(() => {
    const ref = wsRef.current;
    wsRef.current = null;
    ref?.close();
  }, []);

  return { close };
}
```

Key design: Pass `onMessage` callback instead of returning state -- this lets ProcessingStep dispatch to Zustand directly without triggering re-renders on every WS message through the hook's own state.

**ProgressBar.tsx -- Animated progress display:**

Props: `progress: BatchProgress | null`.

Display:
- Top row: `{current} / {total} items` on left, `~{Math.ceil(eta_seconds)}s remaining` on right (only show ETA if eta_seconds is truthy).
- Middle: A `div` bar with `h-2 bg-parchment-dark rounded overflow-hidden` container and inner `div` with `bg-archive-sepia transition-all duration-500 ease-out` and width set via `style={{ width: \`${percentage}%\` }}`.
- Bottom: `Processing: {last_result?.filename}` in `font-mono text-sm`.

Use the parchment aesthetic: `text-xs uppercase tracking-widest text-archive-ink/40 font-semibold` for labels. Match the style of existing components (see ConfigureStep.tsx, FieldManager.tsx).

If `progress` is null, show a "Waiting for connection..." message with subtle pulse animation.

**LiveFeed.tsx -- Scrolling log of completed images:**

Props: `items: ExtractionResult[]`.

Display:
- Container with `max-h-64 overflow-y-auto` for scrollable area.
- Each item rendered as a compact card/row:
  - Success: `border-l-4 border-green-700/30 bg-parchment-light/30 p-3` with filename and extracted fields shown as `key: value` pairs in a compact grid.
  - Failure: `border-l-4 border-red-500/30 bg-red-50/20 p-3` with filename and error message. (Claude's discretion: use red inline entry, not toast, for failures in the live feed -- toasts would be overwhelming during batch processing).
- Auto-scroll to bottom when new items appear using a `useEffect` + `scrollIntoView` on a bottom sentinel ref.
- Show items in reverse order is NOT needed -- append at bottom with auto-scroll is more natural (like watching a log, per user's specific idea).
- If items is empty, show "Awaiting first result..." in italics.

**ProcessingStep.tsx -- Main orchestrator component:**

This component wires everything together. Key responsibilities:

1. **Connect to WebSocket** on mount using `useProcessingWebSocket(batchId, handleProgress)`.

2. **Handle each progress message** in `handleProgress` callback:
   - Call `setLastProgress(progress)`.
   - If `progress.last_result` exists:
     - Call `appendLiveFeedItem(progress.last_result)`.
     - If `last_result.success === false`: call `incrementConsecutiveFailures()`.
     - If `last_result.success === true`: call `resetConsecutiveFailures()`.
   - If `progress.status === 'completed'` or `progress.status === 'cancelled'`:
     - Call `setIsProcessing(false)`.
     - Show "Complete!" message.
     - After a 2-second delay, auto-navigate to results: `setStep('results')`.

3. **Catastrophic failure detection**: Read `processingState.consecutiveFailures` from store. If >= 3, close WebSocket, call `cancelBatch`, set `isProcessing(false)`, and render a full-screen error card with troubleshooting hints:
   - "Processing stopped after 3 consecutive failures"
   - "Check your OPENROUTER_API_KEY in the .env file"
   - "Verify your internet connection"
   - A "Return to Configure" button that calls `setStep('configure')`.

4. **Cancel button**: Visible during processing. On click:
   - Call `cancelBatch(batchName)` via the API.
   - Call `setCancelled(true)`.
   - Show "Cancelling... finishing current image" toast via sonner.
   - The WS will eventually deliver a `status: 'cancelled'` message which triggers navigation to results.

5. **Layout**: Stack vertically:
   - Header: "Processing Collection" with batch name.
   - ProgressBar component.
   - Cancel button (right-aligned, styled as subtle/destructive).
   - LiveFeed component.
   - (Catastrophic error overlay if triggered).

6. **On mount**: call `setIsProcessing(true)` and `resetProcessing()` to clear any stale state from a previous run. BUT only reset if there's no existing progress (to handle page refresh mid-processing -- the WS will re-send current state on reconnect).

**App.tsx -- Wire ProcessingStep into the step switch:**

1. Import `ProcessingStep` from `./features/processing/ProcessingStep`.
2. Replace the placeholder `case 'processing':` div with `<ProcessingStep />`.
3. Keep the `case 'results':` placeholder for now (Plan 03 will replace it).
  </action>
  <verify>
Run `cd /Users/martinhess/workspace/hack-the-heritage/Indexcards_OCR/apps/frontend && npx tsc --noEmit` to verify no TypeScript errors.
Verify all new files exist: `ls apps/frontend/src/features/processing/` should show 4 files.
  </verify>
  <done>
ProcessingStep renders with ProgressBar and LiveFeed, connects via WebSocket, handles cancel, detects catastrophic failures (3 consecutive), auto-navigates to results on completion. App.tsx renders ProcessingStep for the processing wizard step.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/frontend && npx tsc --noEmit` passes with zero errors.
2. All feature files exist: `ls apps/frontend/src/features/processing/` shows useProcessingWebSocket.ts, ProcessingStep.tsx, ProgressBar.tsx, LiveFeed.tsx.
3. Zustand store has partialize: grep for "partialize" in wizardStore.ts.
4. App.tsx imports and renders ProcessingStep.
5. batchesApi.ts exports cancelBatch, fetchResults, retryImage, and their mutation/query hooks.
</verification>

<success_criteria>
- WebSocket hook connects to /api/v1/ws/task/{batchId} and delivers parsed BatchProgress to callback
- ProcessingStep shows real-time progress bar with percentage, X/Y, current filename, ETA
- LiveFeed scrolls and shows extracted data per image with success/failure styling
- Cancel button triggers POST /cancel and partial results are preserved
- 3 consecutive failures triggers catastrophic error screen with troubleshooting hints
- Completion triggers auto-navigate to results step after ~2s delay
- Zustand persist excludes processingState and results via partialize
</success_criteria>

<output>
After completion, create `.planning/phases/03-processing-results-react/03-02-SUMMARY.md`
</output>
