---
phase: 03.1-dynamic-prompt-generation-from-field-definitions-with-configurable-prompt-template
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/frontend/src/features/configure/PromptTemplateEditor.tsx
  - apps/backend/app/services/ocr_engine.py
  - apps/backend/app/services/template_service.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Default prompt template is domain-agnostic — no reference to music, Musik, or any specific archive domain"
    - "Saving a template with a custom prompt_template persists the value to disk"
    - "Loading a saved template restores the prompt_template in the frontend editor"
  artifacts:
    - path: "apps/frontend/src/features/configure/PromptTemplateEditor.tsx"
      provides: "Domain-agnostic DEFAULT_TEMPLATE constant"
      contains: "historischer Archivkarteikarten"
      must_not_contain: "aus dem Bereich Musik"
    - path: "apps/backend/app/services/ocr_engine.py"
      provides: "Domain-agnostic hardcoded default prompt in _generate_prompt()"
      contains: "historischer Archivkarteikarten"
      must_not_contain: "aus dem Bereich Musik"
    - path: "apps/backend/app/services/template_service.py"
      provides: "prompt_template persistence in create_template() and update_template()"
      contains: "prompt_template"
  key_links:
    - from: "apps/frontend/src/features/configure/PromptTemplateEditor.tsx"
      to: "apps/backend/app/services/ocr_engine.py"
      via: "DEFAULT_TEMPLATE constant must be identical text to ocr_engine.py hardcoded default"
      pattern: "Du bist ein Experte"
    - from: "apps/backend/app/services/template_service.py"
      to: "apps/backend/app/models/schemas.py"
      via: "Template constructor receives prompt_template from TemplateCreate/TemplateUpdate"
      pattern: "prompt_template"
---

<objective>
Close 2 UAT gaps from Phase 03.1: (1) remove domain-specific "aus dem Bereich Musik" from both frontend and backend default prompt templates, making them generic for any type of historical archive card; (2) fix template_service.py create_template() and update_template() to persist prompt_template to disk.

Purpose: UAT tests 1 and 6 failed — the default prompt is music-specific (should be domain-agnostic) and template save/load drops the prompt_template field.
Output: All three files patched; default prompt is generic; template save round-trips prompt_template.
</objective>

<execution_context>
@/Users/martinhess/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martinhess/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-dynamic-prompt-generation-from-field-definitions-with-configurable-prompt-template/03.1-01-SUMMARY.md
@.planning/phases/03.1-dynamic-prompt-generation-from-field-definitions-with-configurable-prompt-template/03.1-02-SUMMARY.md
@apps/frontend/src/features/configure/PromptTemplateEditor.tsx
@apps/backend/app/services/ocr_engine.py
@apps/backend/app/services/template_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make default prompt domain-agnostic in frontend and backend</name>
  <files>
    apps/frontend/src/features/configure/PromptTemplateEditor.tsx
    apps/backend/app/services/ocr_engine.py
  </files>
  <action>
Both files contain a hardcoded German default prompt that includes the phrase "aus dem Bereich Musik" (domain-specific to music index cards). Remove this phrase from both locations so the prompt is generic for any type of historical archive card.

**CRITICAL:** The two strings must remain IDENTICAL after the fix (the null-means-default pattern depends on exact text match).

**In `PromptTemplateEditor.tsx` (line 5), change the DEFAULT_TEMPLATE constant:**
- OLD first line: `Du bist ein Experte für die Digitalisierung historischer Archivkarteikarten aus dem Bereich Musik.`
- NEW first line: `Du bist ein Experte für die Digitalisierung historischer Archivkarteikarten.`
- Rest of the template stays exactly the same (Handschrift, Streichungen, fields placeholder, empty string instruction, AUSGABEFORMAT).

**In `ocr_engine.py` (_generate_prompt method, around line 93), change the hardcoded default f-string:**
- OLD first line: `Du bist ein Experte für die Digitalisierung historischer Archivkarteikarten aus dem Bereich Musik.`
- NEW first line: `Du bist ein Experte für die Digitalisierung historischer Archivkarteikarten.`
- Rest of the prompt stays exactly the same.

**Do NOT change any other text** — only remove the " aus dem Bereich Musik" substring from the first line of each default prompt. The rest of the German text (Handschrift, Streichungen, leeren String, Tippfehlern, AUSGABEFORMAT) must remain unchanged.

After editing, verify both strings match character-for-character by extracting them and comparing.
  </action>
  <verify>
1. `grep "aus dem Bereich Musik" apps/frontend/src/features/configure/PromptTemplateEditor.tsx apps/backend/app/services/ocr_engine.py` returns NO matches.
2. `grep "historischer Archivkarteikarten\." apps/frontend/src/features/configure/PromptTemplateEditor.tsx apps/backend/app/services/ocr_engine.py` returns matches in BOTH files (confirming the generic text is present).
3. Extract the DEFAULT_TEMPLATE from the frontend and the hardcoded prompt from the backend, diff them — they must be identical (excluding the f-string `{fields_block}` vs `{{fields}}` placeholder syntax).
  </verify>
  <done>Both default prompt templates are domain-agnostic (no mention of Musik or any specific domain). The two strings match exactly so the null-means-default sentinel pattern continues to work.</done>
</task>

<task type="auto">
  <name>Task 2: Fix template_service to persist prompt_template on create and update</name>
  <files>apps/backend/app/services/template_service.py</files>
  <action>
The `create_template()` and `update_template()` methods in `template_service.py` do not pass `prompt_template` through, so it is silently dropped.

**In `create_template()` (line 41-50):**
The Template constructor is called with only `id`, `name`, `fields`. Add `prompt_template=template_in.prompt_template` to the constructor call:

```python
new_template = Template(
    id=str(uuid.uuid4()),
    name=template_in.name,
    fields=template_in.fields,
    prompt_template=template_in.prompt_template
)
```

The `TemplateCreate` Pydantic model already has `prompt_template: Optional[str] = None` (added in Plan 01), so `template_in.prompt_template` is always available.

**In `update_template()` (line 52-61):**
Add handling for `prompt_template` after the existing `fields` check, following the same pattern:

```python
if template_in.prompt_template is not None:
    templates[i]["prompt_template"] = template_in.prompt_template
```

Note: This uses the same `is not None` guard as the existing `name` and `fields` checks, meaning a PATCH with no `prompt_template` key leaves the existing value unchanged, while explicitly sending `prompt_template: "some text"` updates it. The `TemplateUpdate` model also already has `prompt_template: Optional[str] = None`.

**Edge case consideration:** If the user wants to CLEAR a custom prompt_template back to null/default, they would need to send `prompt_template: null`. However, the current `is not None` guard will skip null values. This is acceptable because:
- The frontend "Reset to default" button sets the Zustand store to `null`, which means the field is omitted from the save payload (same as not sending it).
- A full template re-save with `null` prompt_template goes through `create_template` which passes it through directly.
- This matches the existing pattern for `name` and `fields` in update_template.

If explicitly clearing prompt_template is needed later, a separate enhancement can add `"prompt_template": None` handling. For now, the existing pattern is consistent.
  </action>
  <verify>
1. Read `template_service.py` and confirm `prompt_template=template_in.prompt_template` appears in `create_template()`.
2. Read `template_service.py` and confirm `prompt_template` handling appears in `update_template()`.
3. Run `python -c "from app.services.template_service import template_service; print('import ok')"` from the backend directory to verify no syntax errors.
  </verify>
  <done>template_service.py persists prompt_template on both create and update. Saving a template with a custom prompt and reloading it restores the prompt_template value.</done>
</task>

</tasks>

<verification>
1. `grep -r "aus dem Bereich Musik" apps/` returns zero matches across the entire codebase.
2. Both DEFAULT_TEMPLATE (frontend) and _generate_prompt default (backend) contain "historischer Archivkarteikarten." (with period, no domain qualifier).
3. `template_service.py` create_template passes prompt_template to Template constructor.
4. `template_service.py` update_template handles prompt_template updates.
5. TypeScript compilation succeeds: `cd apps/frontend && npx tsc --noEmit`.
6. Backend Python imports succeed without errors.
</verification>

<success_criteria>
- UAT Test 1 (domain-agnostic default prompt): PASS — no music-specific text in either default prompt
- UAT Test 6 (template save persists prompt): PASS — prompt_template round-trips through save/load
- Both DEFAULT_TEMPLATE strings (frontend + backend) remain identical after the fix
- No regressions in existing functionality (TypeScript compiles, Python imports work)
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-dynamic-prompt-generation-from-field-definitions-with-configurable-prompt-template/03.1-03-SUMMARY.md`
</output>
