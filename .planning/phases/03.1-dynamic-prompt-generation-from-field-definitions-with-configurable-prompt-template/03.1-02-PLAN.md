---
phase: 03.1-dynamic-prompt-generation-from-field-definitions-with-configurable-prompt-template
plan: 02
type: execute
wave: 2
depends_on: ["03.1-01"]
files_modified:
  - apps/frontend/src/store/wizardStore.ts
  - apps/frontend/src/features/configure/PromptTemplateEditor.tsx
  - apps/frontend/src/features/configure/ConfigureStep.tsx
  - apps/frontend/src/features/configure/TemplateSelector.tsx
  - apps/frontend/src/features/configure/FieldManager.tsx
  - apps/frontend/src/api/templatesApi.ts
  - apps/frontend/src/api/batchesApi.ts
autonomous: true

must_haves:
  truths:
    - "User can see and edit a prompt template textarea in the Configure step"
    - "User can see a live preview of the rendered prompt with current fields substituted"
    - "User can reset the prompt template to the default"
    - "Saving a template persists the prompt_template alongside fields"
    - "Loading a template from TemplateSelector applies its prompt_template to the store"
    - "Starting a batch sends prompt_template in the BatchCreate payload"
    - "promptTemplate state persists across page refresh via Zustand localStorage"
  artifacts:
    - path: "apps/frontend/src/features/configure/PromptTemplateEditor.tsx"
      provides: "Collapsible prompt template editor with textarea, {{fields}} hint, live preview, reset button"
      min_lines: 40
    - path: "apps/frontend/src/store/wizardStore.ts"
      provides: "promptTemplate state and setPromptTemplate action"
      contains: "promptTemplate"
    - path: "apps/frontend/src/api/batchesApi.ts"
      provides: "prompt_template in BatchCreate interface and payload"
      contains: "prompt_template"
    - path: "apps/frontend/src/api/templatesApi.ts"
      provides: "prompt_template in Template interface and create/update mutation payloads"
      contains: "prompt_template"
  key_links:
    - from: "apps/frontend/src/features/configure/PromptTemplateEditor.tsx"
      to: "apps/frontend/src/store/wizardStore.ts"
      via: "useWizardStore reads fields + promptTemplate, calls setPromptTemplate"
      pattern: "useWizardStore.*promptTemplate"
    - from: "apps/frontend/src/features/configure/ConfigureStep.tsx"
      to: "apps/frontend/src/api/batchesApi.ts"
      via: "createBatchMutation payload includes prompt_template from store"
      pattern: "prompt_template.*promptTemplate"
    - from: "apps/frontend/src/features/configure/TemplateSelector.tsx"
      to: "apps/frontend/src/store/wizardStore.ts"
      via: "handleSelectTemplate calls setPromptTemplate with loaded template's prompt_template"
      pattern: "setPromptTemplate"
    - from: "apps/frontend/src/features/configure/FieldManager.tsx"
      to: "apps/frontend/src/api/templatesApi.ts"
      via: "handleSaveTemplate includes promptTemplate in create mutation payload"
      pattern: "prompt_template"
---

<objective>
Add the prompt template editor UI to the Configure step and wire prompt_template through all frontend data flows: Zustand store, template save/load, and batch creation.

Purpose: Give users a textarea to customize the VLM prompt instruction, with a live preview showing the rendered prompt with current fields substituted, and ensure the template value flows through template save/load and batch creation API calls.

Output: New PromptTemplateEditor component, updated wizardStore, updated API layers, and wired ConfigureStep/TemplateSelector/FieldManager.
</objective>

<execution_context>
@/Users/martinhess/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martinhess/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-dynamic-prompt-generation-from-field-definitions-with-configurable-prompt-template/03.1-RESEARCH.md
@.planning/phases/03.1-dynamic-prompt-generation-from-field-definitions-with-configurable-prompt-template/03.1-01-SUMMARY.md
@apps/frontend/src/store/wizardStore.ts
@apps/frontend/src/features/configure/ConfigureStep.tsx
@apps/frontend/src/features/configure/TemplateSelector.tsx
@apps/frontend/src/features/configure/FieldManager.tsx
@apps/frontend/src/features/configure/SaveTemplateDialog.tsx
@apps/frontend/src/api/templatesApi.ts
@apps/frontend/src/api/batchesApi.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Zustand store, API layers, and template/batch data flows with prompt_template</name>
  <files>
    apps/frontend/src/store/wizardStore.ts
    apps/frontend/src/api/templatesApi.ts
    apps/frontend/src/api/batchesApi.ts
    apps/frontend/src/features/configure/TemplateSelector.tsx
    apps/frontend/src/features/configure/FieldManager.tsx
    apps/frontend/src/features/configure/ConfigureStep.tsx
  </files>
  <action>
1. **wizardStore.ts** — Add promptTemplate state:
   - Add to `WizardState` interface:
     ```typescript
     promptTemplate: string | null;
     setPromptTemplate: (t: string | null) => void;
     ```
   - Add to `initialState`:
     ```typescript
     promptTemplate: null,
     ```
   - Add to create() body:
     ```typescript
     setPromptTemplate: (promptTemplate) => set({ promptTemplate }),
     ```
   - In `resetWizard`, the spread of `initialState` already covers it since `promptTemplate: null` is in initialState.
   - In `partialize`, add `promptTemplate: state.promptTemplate` so it persists to localStorage.

2. **templatesApi.ts** — Add prompt_template to Template interface and mutations:
   - Add `prompt_template?: string | null;` to the `Template` interface.
   - Update `useCreateTemplateMutation` mutationFn data type to: `{ name: string; fields: string[]; prompt_template?: string | null }`.
   - Update `useUpdateTemplateMutation` mutationFn data type to: `{ id: string; name?: string; fields?: string[]; prompt_template?: string | null }`.

3. **batchesApi.ts** — Add prompt_template to BatchCreate:
   - Add `prompt_template?: string | null;` to the `BatchCreate` interface.

4. **TemplateSelector.tsx** — Apply prompt_template when loading a template:
   - Destructure `setPromptTemplate` from `useWizardStore()` (add alongside `setFields`).
   - Update `handleSelectTemplate` signature to accept a 4th parameter: `promptTemplate: string | null | undefined`.
   - Inside `handleSelectTemplate`, call `setPromptTemplate(promptTemplate ?? null)` after `setFields(newFields)`.
   - In `handleSelectBlank`, call `setPromptTemplate(null)` after `setFields([])`.
   - Update the template map's onClick to pass `t.prompt_template`: `onClick={() => handleSelectTemplate(t.id, t.name, t.fields, t.prompt_template)}`.

5. **FieldManager.tsx** — Include promptTemplate when saving a template:
   - Destructure `promptTemplate` from `useWizardStore()`.
   - Update `handleSaveTemplate` to include prompt_template:
     ```typescript
     createTemplateMutation.mutate({
       name,
       fields: fields.map((f) => f.label),
       prompt_template: promptTemplate,
     });
     ```

6. **ConfigureStep.tsx** — Include promptTemplate in batch creation payload:
   - Destructure `promptTemplate` from `useWizardStore()` (add alongside existing destructured state).
   - Update `createBatchMutation.mutate()` call to include `prompt_template: promptTemplate`:
     ```typescript
     createBatchMutation.mutate(
       {
         custom_name: batchName.trim(),
         session_id: sessionId,
         fields: fieldLabels,
         prompt_template: promptTemplate,
       },
       { onSuccess: ... }
     );
     ```
  </action>
  <verify>
    - `grep -n "promptTemplate" apps/frontend/src/store/wizardStore.ts` shows the state field, setter, initialState, and partialize entries.
    - `grep -n "prompt_template" apps/frontend/src/api/templatesApi.ts` shows it in Template interface and mutation types.
    - `grep -n "prompt_template" apps/frontend/src/api/batchesApi.ts` shows it in BatchCreate interface.
    - `grep -n "setPromptTemplate" apps/frontend/src/features/configure/TemplateSelector.tsx` shows it called in handleSelectTemplate and handleSelectBlank.
    - `grep -n "prompt_template" apps/frontend/src/features/configure/FieldManager.tsx` shows it in the createTemplateMutation.mutate call.
    - `grep -n "prompt_template" apps/frontend/src/features/configure/ConfigureStep.tsx` shows it in the createBatchMutation.mutate call.
    - `cd apps/frontend && npx tsc --noEmit` passes.
  </verify>
  <done>promptTemplate state is in Zustand (persisted to localStorage). Templates save/load prompt_template. Batches include prompt_template in creation payload. All data flows carry the value end-to-end on the frontend.</done>
</task>

<task type="auto">
  <name>Task 2: Create PromptTemplateEditor component and integrate into ConfigureStep</name>
  <files>
    apps/frontend/src/features/configure/PromptTemplateEditor.tsx
    apps/frontend/src/features/configure/ConfigureStep.tsx
  </files>
  <action>
1. **Create** `apps/frontend/src/features/configure/PromptTemplateEditor.tsx`:

   A collapsible prompt template editor with:
   - A header row with "Prompt Template" title (font-serif, archive-ink color) and an expand/collapse toggle (use ChevronDown from lucide-react, rotate when expanded).
   - Collapsed by default (use `useState(false)` for `isExpanded`).
   - When expanded, show:
     a. A hint paragraph: "Use `{{fields}}` as the placeholder where the field list will appear. Leave blank to use the default template." — styled as `text-xs text-archive-ink/60 italic`.
     b. An Edit/Preview toggle button (text-sm underline, archive-sepia color).
     c. In **Edit mode**: A `<textarea>` with:
        - `className="w-full h-48 font-mono text-sm bg-parchment-light/30 border border-parchment-dark/50 rounded p-3 focus:outline-none focus:border-archive-sepia/50 resize-y"`
        - value = `promptTemplate ?? DEFAULT_TEMPLATE` (where DEFAULT_TEMPLATE is the full default German prompt text — copy exactly from ocr_engine.py's _generate_prompt hardcoded string, but with `{{fields}}` replacing the fields_description placeholder area).
        - onChange: `setPromptTemplate(e.target.value === DEFAULT_TEMPLATE ? null : e.target.value || null)` — if user types exactly the default, treat as null; if empty string, treat as null.
     d. In **Preview mode**: A `<pre>` block showing the rendered prompt with current fields substituted. Compute preview using:
        ```typescript
        const fieldsBlock = fields
          .map((f, i) => `${i + 1}. **${f.label}**: Extrahiere den Wert fur das Feld '${f.label}'.`)
          .join('\n');
        const preview = effectiveTemplate.includes('{{fields}}')
          ? effectiveTemplate.replace('{{fields}}', fieldsBlock)
          : effectiveTemplate + '\n\n' + fieldsBlock;
        ```
        Style: `text-xs font-mono bg-parchment-dark/5 border border-parchment-dark/30 rounded p-4 whitespace-pre-wrap max-h-64 overflow-y-auto`.
     e. A "Reset to default" button (only visible when `promptTemplate !== null`): `text-xs text-archive-ink/50 hover:text-archive-ink underline`. onClick: `setPromptTemplate(null)`.

   The DEFAULT_TEMPLATE constant should be:
   ```
   Du bist ein Experte fur die Digitalisierung historischer Archivkarteikarten aus dem Bereich Musik.

   Deine Aufgabe ist es, die Informationen von der Karteikarte prazise zu extrahieren.
   Achte besonders auf die Handschrift und mogliche Streichungen.

   **Extrahiere folgende Felder:**
   {{fields}}

   Falls ein Feld nicht auf der Karte vorhanden ist oder nicht entziffert werden kann, verwende einen leeren String ("").
   Andere nichts an der Schreibweise historischer Begriffe, ausser bei offensichtlichen Tippfehlern.

   **AUSGABEFORMAT:** Antworte NUR mit einem validen JSON-Objekt.
   ```
   (Use the actual German text with proper umlauts from ocr_engine.py — copy the exact strings.)

   Component reads from Zustand: `const { fields, promptTemplate, setPromptTemplate } = useWizardStore();`

2. **Update** `apps/frontend/src/features/configure/ConfigureStep.tsx`:
   - Import `PromptTemplateEditor` from `./PromptTemplateEditor`.
   - Place `<PromptTemplateEditor />` in the right column (lg:col-span-8 area), **below** the `<FieldManager />` component. Wrap it in a div if spacing is needed: `<div className="mt-6"><PromptTemplateEditor /></div>`.

   The layout should be:
   ```
   Left column (lg:col-span-4): Batch Identity, TemplateSelector, Summary, ImagePreview, Info
   Right column (lg:col-span-8): FieldManager, PromptTemplateEditor (below fields)
   ```
  </action>
  <verify>
    - File exists: `ls apps/frontend/src/features/configure/PromptTemplateEditor.tsx`
    - `grep -n "PromptTemplateEditor" apps/frontend/src/features/configure/ConfigureStep.tsx` shows import and usage.
    - `grep -n "DEFAULT_TEMPLATE" apps/frontend/src/features/configure/PromptTemplateEditor.tsx` shows the constant.
    - `grep -n "fields" apps/frontend/src/features/configure/PromptTemplateEditor.tsx` shows live preview computation.
    - `cd apps/frontend && npx tsc --noEmit` passes.
    - `cd apps/frontend && npx vite build` succeeds.
  </verify>
  <done>PromptTemplateEditor component is visible in the Configure step below the field list. Users can expand it, edit the prompt template, see a live preview with current fields substituted, and reset to default. The component reads/writes promptTemplate via Zustand store.</done>
</task>

</tasks>

<verification>
1. wizardStore has promptTemplate state persisted to localStorage.
2. PromptTemplateEditor renders in Configure step (collapsed by default, expandable).
3. Editing the textarea updates Zustand promptTemplate.
4. Preview mode shows rendered prompt with current field labels substituted.
5. Reset button clears promptTemplate to null (triggers default prompt on backend).
6. Saving a template via SaveTemplateDialog includes prompt_template in the API payload.
7. Loading a template via TemplateSelector sets promptTemplate in store.
8. Loading "Custom / Blank Slate" resets promptTemplate to null.
9. Creating a batch includes prompt_template in the BatchCreate payload.
10. TypeScript compilation and Vite build both succeed.
</verification>

<success_criteria>
- PromptTemplateEditor is visible and functional in the Configure step.
- Live preview reflects current fields and template text in real time.
- Template save/load carries prompt_template alongside fields.
- Batch creation sends prompt_template to the backend.
- All TypeScript types are satisfied (tsc --noEmit passes).
- Vite production build succeeds.
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-dynamic-prompt-generation-from-field-definitions-with-configurable-prompt-template/03.1-02-SUMMARY.md`
</output>
