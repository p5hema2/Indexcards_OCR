---
phase: 02.1-add-turbo
plan: 03
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - packages/shared-types/package.json
  - packages/shared-types/schemas/batch.schema.json
  - packages/shared-types/schemas/upload.schema.json
  - packages/shared-types/schemas/template.schema.json
  - packages/shared-types/schemas/progress.schema.json
  - packages/shared-types/schemas/health.schema.json
  - packages/shared-types/scripts/generate.mjs
  - packages/shared-types/scripts/bootstrap-schemas.py
  - packages/shared-types/generated/ts/index.ts
  - packages/shared-types/tsconfig.json
autonomous: true

must_haves:
  truths:
    - "JSON Schema files exist as single source of truth for API contracts"
    - "TypeScript interfaces are generated from JSON Schema"
    - "Pydantic models can be generated from JSON Schema (script exists)"
    - "Frontend can import types via @indexcards/shared-types"
    - "turbo generate produces fresh TypeScript and Pydantic output"
  artifacts:
    - path: "packages/shared-types/package.json"
      provides: "Shared types workspace package"
      contains: "@indexcards/shared-types"
    - path: "packages/shared-types/schemas/"
      provides: "JSON Schema source-of-truth files"
    - path: "packages/shared-types/scripts/generate.mjs"
      provides: "Codegen script for TypeScript + Pydantic from JSON Schema"
    - path: "packages/shared-types/generated/ts/index.ts"
      provides: "Generated TypeScript interfaces"
    - path: "packages/shared-types/tsconfig.json"
      provides: "TypeScript config for shared-types package"
  key_links:
    - from: "packages/shared-types/scripts/generate.mjs"
      to: "packages/shared-types/schemas/"
      via: "reads JSON Schema files as input"
      pattern: "schemas/"
    - from: "packages/shared-types/scripts/generate.mjs"
      to: "packages/shared-types/generated/ts/"
      via: "writes generated TypeScript interfaces"
      pattern: "generated/ts"
    - from: "apps/frontend/package.json"
      to: "packages/shared-types/package.json"
      via: "workspace dependency @indexcards/shared-types: *"
      pattern: "@indexcards/shared-types"
---

<objective>
Create the packages/shared-types workspace with JSON Schema as the single source of truth for API contracts, and codegen scripts that produce both TypeScript interfaces and Pydantic models. Bootstrap the initial schemas from the existing Pydantic models in apps/backend.

Purpose: Per locked decision, cross-language type generation uses a single source of truth (JSON Schema) to generate both TypeScript interfaces and Pydantic models, preventing drift between frontend and backend API contracts. This is foundational infrastructure that all future API changes flow through.

Output: packages/shared-types with JSON Schema files, codegen scripts, generated TypeScript interfaces, and a bootstrap script for initial schema extraction from Pydantic models.
</objective>

<execution_context>
@/Users/martinhess/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martinhess/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-add-turbo/02.1-RESEARCH.md
@.planning/phases/02.1-add-turbo/02.1-01-SUMMARY.md
@apps/backend/app/models/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bootstrap JSON Schema from existing Pydantic models and create shared-types package</name>
  <files>
    packages/shared-types/package.json
    packages/shared-types/tsconfig.json
    packages/shared-types/schemas/batch.schema.json
    packages/shared-types/schemas/upload.schema.json
    packages/shared-types/schemas/template.schema.json
    packages/shared-types/schemas/progress.schema.json
    packages/shared-types/schemas/health.schema.json
    packages/shared-types/scripts/bootstrap-schemas.py
  </files>
  <action>
**Step 1: Create packages/shared-types/package.json**

```json
{
  "name": "@indexcards/shared-types",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "exports": {
    ".": {
      "types": "./generated/ts/index.ts",
      "default": "./generated/ts/index.ts"
    }
  },
  "scripts": {
    "generate": "node scripts/generate.mjs",
    "build": "npm run generate",
    "clean": "rm -rf generated/ts generated/py"
  },
  "devDependencies": {
    "json-schema-to-typescript": "^15.0.0"
  }
}
```

Source-only package (no build step for consumers). The frontend imports directly from generated TypeScript files via the `exports` field. The `build` script runs generation so turbo's `^build` dependency chain works.

**Step 2: Create packages/shared-types/tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./generated/ts"
  },
  "include": ["generated/ts/**/*.ts"]
}
```

**Step 3: Create bootstrap script**

Create `packages/shared-types/scripts/bootstrap-schemas.py`. This is a ONE-TIME script that extracts JSON Schema from the existing Pydantic models. Run it once to produce the initial schemas, then commit those schemas as the source of truth.

```python
#!/usr/bin/env python3
"""
One-time bootstrap: extract JSON Schema from existing Pydantic models.
Run from repo root: python packages/shared-types/scripts/bootstrap-schemas.py

After running, the generated .schema.json files become the source of truth.
Edit them directly for future changes, NOT the Pydantic models.
"""
import json
import sys
import os

# Add backend to path so we can import models
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', '..', 'apps', 'backend'))

from app.models.schemas import (
    HealthCheck, ExtractionResult, BatchConfig, BatchCreate,
    BatchResponse, BatchHistory, UploadResponse,
    Template, TemplateCreate, TemplateUpdate, BatchProgress
)

SCHEMAS_DIR = os.path.join(os.path.dirname(__file__), '..', 'schemas')
os.makedirs(SCHEMAS_DIR, exist_ok=True)

# Group models by domain
groups = {
    'health': [HealthCheck],
    'batch': [BatchConfig, BatchCreate, BatchResponse, BatchHistory, ExtractionResult],
    'upload': [UploadResponse],
    'template': [Template, TemplateCreate, TemplateUpdate],
    'progress': [BatchProgress],
}

for group_name, models in groups.items():
    schema = {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "title": f"{group_name.capitalize()} API Types",
        "definitions": {}
    }
    for model in models:
        model_schema = model.model_json_schema()
        # Remove the top-level $defs if present (Pydantic v2 puts refs there)
        defs = model_schema.pop('$defs', {})
        schema['definitions'][model.__name__] = model_schema
        # Merge any nested $defs
        for def_name, def_schema in defs.items():
            schema['definitions'][def_name] = def_schema

    outpath = os.path.join(SCHEMAS_DIR, f'{group_name}.schema.json')
    with open(outpath, 'w') as f:
        json.dump(schema, f, indent=2)
    print(f'  Written: {outpath}')

print(f'\nBootstrap complete. {len(groups)} schema files created.')
print('These are now the source of truth. Edit .schema.json files for future changes.')
```

**Step 4: Run the bootstrap script**

Execute the bootstrap script to generate the initial JSON Schema files. This requires the backend's Python dependencies to be available. If they aren't installed yet (setup hasn't run), create the schemas manually based on the Pydantic models in `apps/backend/app/models/schemas.py`.

The script should produce:
- `packages/shared-types/schemas/health.schema.json`
- `packages/shared-types/schemas/batch.schema.json`
- `packages/shared-types/schemas/upload.schema.json`
- `packages/shared-types/schemas/template.schema.json`
- `packages/shared-types/schemas/progress.schema.json`

If the bootstrap script cannot run (missing Python deps), create the schema files manually by hand-translating the 12 Pydantic models from `apps/backend/app/models/schemas.py` into JSON Schema draft-07 format. The models are simple (string, int, float, optional, list, dict fields) so hand-translation is straightforward.

**Step 5: Create directory structure**

```
packages/shared-types/
├── package.json
├── tsconfig.json
├── schemas/
│   ├── batch.schema.json
│   ├── health.schema.json
│   ├── progress.schema.json
│   ├── template.schema.json
│   └── upload.schema.json
├── scripts/
│   ├── bootstrap-schemas.py
│   └── generate.mjs (Task 2)
└── generated/
    ├── ts/ (Task 2)
    └── py/ (Task 2)
```

Create the `generated/ts/` and `generated/py/` directories as empty placeholders with `.gitkeep` files.
  </action>
  <verify>
test -f packages/shared-types/package.json && echo "package.json exists"
test -f packages/shared-types/tsconfig.json && echo "tsconfig.json exists"
ls packages/shared-types/schemas/*.schema.json | wc -l | tr -d ' ' | xargs -I{} test {} -ge 4 && echo "At least 4 schema files exist"
test -f packages/shared-types/scripts/bootstrap-schemas.py && echo "Bootstrap script exists"
  </verify>
  <done>packages/shared-types workspace created with package.json, tsconfig.json, bootstrap script, and 5 JSON Schema files (health, batch, upload, template, progress) extracted from existing Pydantic models. Schemas are now the source of truth for API contracts.</done>
</task>

<task type="auto">
  <name>Task 2: Create codegen scripts and generate initial TypeScript interfaces</name>
  <files>
    packages/shared-types/scripts/generate.mjs
    packages/shared-types/generated/ts/index.ts
  </files>
  <action>
**Step 1: Create the codegen script**

Create `packages/shared-types/scripts/generate.mjs`. This script:
1. Reads all `.schema.json` files from `schemas/`
2. Generates TypeScript interfaces using `json-schema-to-typescript`
3. Optionally generates Pydantic models using `datamodel-code-generator` (if available)
4. Writes output to `generated/ts/` and `generated/py/`

```javascript
// packages/shared-types/scripts/generate.mjs
import { compile } from 'json-schema-to-typescript'
import { readFileSync, writeFileSync, mkdirSync, readdirSync, existsSync } from 'fs'
import { resolve, basename } from 'path'
import { execSync } from 'child_process'

const ROOT = resolve(import.meta.dirname, '..')
const SCHEMAS_DIR = resolve(ROOT, 'schemas')
const TS_OUT = resolve(ROOT, 'generated', 'ts')
const PY_OUT = resolve(ROOT, 'generated', 'py')

// Ensure output dirs
mkdirSync(TS_OUT, { recursive: true })
mkdirSync(PY_OUT, { recursive: true })

const schemaFiles = readdirSync(SCHEMAS_DIR).filter(f => f.endsWith('.schema.json'))

if (schemaFiles.length === 0) {
  console.error('No .schema.json files found in schemas/')
  process.exit(1)
}

console.log(`Generating types from ${schemaFiles.length} schema files...\n`)

// --- TypeScript Generation ---
const tsOutputs = []

for (const file of schemaFiles) {
  const schemaPath = resolve(SCHEMAS_DIR, file)
  const schema = JSON.parse(readFileSync(schemaPath, 'utf8'))
  const groupName = basename(file, '.schema.json')

  // Generate TypeScript for each definition in the schema
  const definitions = schema.definitions || {}

  for (const [name, defSchema] of Object.entries(definitions)) {
    try {
      // Add title if missing (json-schema-to-typescript uses it for the interface name)
      const schemaWithTitle = { ...defSchema, title: name }
      const ts = await compile(schemaWithTitle, name, {
        bannerComment: '',
        additionalProperties: false,
        style: { semi: false, singleQuote: true },
      })
      tsOutputs.push(ts)
      console.log(`  TS: ${name}`)
    } catch (err) {
      console.error(`  ERROR generating TS for ${name}: ${err.message}`)
    }
  }
}

// Write combined TypeScript output
const tsHeader = `// AUTO-GENERATED from JSON Schema — do not edit manually\n// Regenerate with: turbo generate (or npm run generate in packages/shared-types)\n\n`
const tsContent = tsHeader + tsOutputs.join('\n')
writeFileSync(resolve(TS_OUT, 'index.ts'), tsContent)
console.log(`\n  Written: generated/ts/index.ts`)

// --- Pydantic Generation (optional, requires datamodel-code-generator) ---
try {
  // Check if datamodel-codegen is available
  execSync('uv run datamodel-codegen --version', { stdio: 'pipe', cwd: resolve(ROOT, '..', '..', 'apps', 'backend') })

  for (const file of schemaFiles) {
    const schemaPath = resolve(SCHEMAS_DIR, file)
    const groupName = basename(file, '.schema.json')
    const pyOutFile = resolve(PY_OUT, `${groupName}.py`)

    try {
      execSync(
        `uv run datamodel-codegen --input "${schemaPath}" --output "${pyOutFile}" --output-model-type pydantic_v2.BaseModel --target-python-version 3.12`,
        { stdio: 'pipe', cwd: resolve(ROOT, '..', '..', 'apps', 'backend') }
      )
      console.log(`  PY: ${groupName}.py`)
    } catch (err) {
      console.error(`  ERROR generating Pydantic for ${groupName}: ${err.stderr?.toString() || err.message}`)
    }
  }

  // Create __init__.py
  const pyModules = schemaFiles.map(f => basename(f, '.schema.json'))
  const pyInit = `# AUTO-GENERATED — do not edit manually\n` +
    pyModules.map(m => `from .${m} import *`).join('\n') + '\n'
  writeFileSync(resolve(PY_OUT, '__init__.py'), pyInit)
  console.log(`  Written: generated/py/__init__.py`)
} catch {
  console.log('\n  Skipping Pydantic generation (datamodel-codegen not available)')
  console.log('  Install it: pip install datamodel-code-generator')
}

console.log('\nGeneration complete.')
```

**Step 2: Install json-schema-to-typescript and run initial generation**

```bash
cd packages/shared-types && npm install
node scripts/generate.mjs
```

This produces `generated/ts/index.ts` with TypeScript interfaces for all API types.

**Step 3: Verify generated output**

The generated `index.ts` should contain interfaces like:
- `HealthCheck`
- `ExtractionResult`
- `BatchConfig`, `BatchCreate`, `BatchResponse`, `BatchHistory`
- `UploadResponse`
- `Template`, `TemplateCreate`, `TemplateUpdate`
- `BatchProgress`

If the TypeScript generation works but Pydantic generation is skipped (because datamodel-code-generator isn't installed yet), that's fine. The Pydantic generation will work after `npm run setup` installs all Python dev deps.

**Step 4: Add generated files to git**

The generated TypeScript files SHOULD be committed (they're the compiled output from the source-of-truth schemas). Add them to git. The generated Python files can also be committed for convenience.

Add to `.gitignore` considerations: Do NOT gitignore `generated/` -- these are derived but committed artifacts (like compiled protobuf). This ensures frontend can import them without running codegen first.
  </action>
  <verify>
test -f packages/shared-types/scripts/generate.mjs && echo "Generate script exists"
test -f packages/shared-types/generated/ts/index.ts && echo "Generated TS exists"
grep -q 'HealthCheck' packages/shared-types/generated/ts/index.ts && echo "HealthCheck type found"
grep -q 'BatchProgress' packages/shared-types/generated/ts/index.ts && echo "BatchProgress type found"
  </verify>
  <done>Codegen script generate.mjs reads all JSON Schema files and produces TypeScript interfaces (and optionally Pydantic models). Initial TypeScript generation complete with all 12 API types. Frontend can now import from @indexcards/shared-types.</done>
</task>

</tasks>

<verification>
After both tasks:

1. **Package is valid:**
   ```
   cat packages/shared-types/package.json | python3 -m json.tool > /dev/null && echo "Valid JSON"
   ```

2. **Schemas exist:**
   ```
   ls packages/shared-types/schemas/*.schema.json
   ```

3. **TypeScript generated:**
   ```
   head -20 packages/shared-types/generated/ts/index.ts
   ```

4. **turbo generate works** (after npm install):
   ```
   cd packages/shared-types && npm run generate
   ```

5. **Frontend can resolve the package** (after npm install at root):
   ```
   node -e "const pkg = require('./packages/shared-types/package.json'); console.log(pkg.name, pkg.exports)"
   ```
</verification>

<success_criteria>
- packages/shared-types workspace exists with valid package.json
- 5 JSON Schema files exist as source of truth (health, batch, upload, template, progress)
- Bootstrap script exists for future Pydantic-to-schema extraction
- Codegen script generates TypeScript interfaces from JSON Schema
- Generated TypeScript index.ts contains interfaces for all 12 Pydantic models
- turbo generate can be run to regenerate types
- Generated files are committed to git
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-add-turbo/02.1-03-SUMMARY.md`
</output>
