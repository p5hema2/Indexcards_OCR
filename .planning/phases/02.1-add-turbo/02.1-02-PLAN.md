---
phase: 02.1-add-turbo
plan: 02
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - apps/backend/package.json
  - apps/backend/.python-version
  - apps/backend/requirements-dev.txt
  - apps/frontend/package.json
  - scripts/setup.mjs
autonomous: true

must_haves:
  truths:
    - "turbo dev starts both Vite and uvicorn in parallel"
    - "turbo dev --filter=frontend runs only the frontend dev server"
    - "turbo dev --filter=backend runs only the backend dev server"
    - "turbo build runs Vite build (frontend) + ruff check + mypy (backend)"
    - "turbo test runs vitest (frontend) + pytest (backend) in parallel"
    - "turbo typecheck runs tsc (frontend) + mypy (backend)"
    - "turbo lint runs ESLint (frontend) + ruff (backend)"
    - "turbo format runs Prettier (frontend) + Black (backend)"
    - "Port conflicts produce a clear error message"
    - "Root setup script creates Python venv and installs requirements automatically"
  artifacts:
    - path: "apps/backend/package.json"
      provides: "Thin npm wrapper for Python backend"
      contains: "@indexcards/backend"
    - path: "apps/backend/.python-version"
      provides: "Python version pin for uv"
      contains: "3.12"
    - path: "apps/backend/requirements-dev.txt"
      provides: "Python dev dependencies (mypy, ruff, black, pytest, datamodel-code-generator)"
    - path: "apps/frontend/package.json"
      provides: "Updated frontend package with workspace name and new scripts"
      contains: "@indexcards/frontend"
    - path: "scripts/setup.mjs"
      provides: "Root setup script for Python venv auto-management"
  key_links:
    - from: "apps/backend/package.json"
      to: "turbo.json"
      via: "turbo discovers backend as workspace via npm workspaces"
      pattern: "@indexcards/backend"
    - from: "apps/frontend/package.json"
      to: "turbo.json"
      via: "turbo discovers frontend as workspace via npm workspaces"
      pattern: "@indexcards/frontend"
    - from: "scripts/setup.mjs"
      to: "apps/backend/requirements.txt"
      via: "uv pip install reads requirements files"
      pattern: "requirements"
---

<objective>
Create per-package configurations so that Turborepo can orchestrate both the frontend and backend as first-class workspaces, add a root setup script for Python venv auto-management, and ensure all turbo commands (dev, build, test, lint, typecheck, format, clean) work end-to-end.

Purpose: Without per-package package.json files with the correct scripts, turbo cannot dispatch tasks to the right executors. The backend needs a thin npm wrapper delegating to Python tooling. The frontend needs updated naming and scripts. The setup script enables one-command project bootstrap.

Output: Backend thin package.json, frontend updated package.json, Python dev dependencies, .python-version, and root setup script.
</objective>

<execution_context>
@/Users/martinhess/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martinhess/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-add-turbo/02.1-RESEARCH.md
@.planning/phases/02.1-add-turbo/02.1-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend thin package.json, .python-version, and requirements-dev.txt</name>
  <files>
    apps/backend/package.json
    apps/backend/.python-version
    apps/backend/requirements-dev.txt
  </files>
  <action>
**Step 1: Create apps/backend/package.json**

This is a thin npm wrapper -- every script delegates to Python tooling via `uv run`. Per locked decisions: dev runs uvicorn, build runs ruff+mypy, test runs pytest, etc.

Include port conflict detection in the dev script: before starting uvicorn, check if port 8000 is in use. Use a small inline node script or shell check. Pattern:

```json
{
  "name": "@indexcards/backend",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "node -e \"const net=require('net');const s=net.createServer();s.once('error',e=>{if(e.code==='EADDRINUSE'){console.error('\\x1b[31mERROR: Port 8000 is already in use. Stop the process using it or choose a different port.\\x1b[0m');process.exit(1)}});s.listen(8000,()=>{s.close(()=>{const{execSync}=require('child_process');try{execSync('uv run uvicorn app.main:app --reload --host 0.0.0.0 --port 8000',{stdio:'inherit'})}catch(e){process.exit(e.status||1)}})})\"",
    "build": "uv run ruff check app/ && uv run mypy app/",
    "typecheck": "uv run mypy app/",
    "test": "uv run pytest tests/ -v --tb=short",
    "lint": "uv run ruff check app/",
    "format": "uv run black app/ && uv run ruff check --fix app/",
    "clean": "node -e \"const fs=require('fs');['.mypy_cache','.ruff_cache','.pytest_cache'].forEach(d=>{fs.rmSync(d,{recursive:true,force:true})});console.log('Backend cleaned')\""
  }
}
```

The dev script uses a Node port-check before spawning uvicorn. If port 8000 is occupied, it prints a red error and exits 1. This satisfies the locked decision "Port conflicts: fail with a clear error message showing which port is occupied."

IMPORTANT: Keep the backend package.json dependency-free. No `dependencies` or `devDependencies` for npm packages. All Python deps are in requirements.txt / requirements-dev.txt, managed by uv. This avoids npm workspace hoisting issues (per research pitfall 3).

**Step 2: Create apps/backend/.python-version**

```
3.12
```

This file tells uv which Python version to use. uv reads it automatically.

**Step 3: Create apps/backend/requirements-dev.txt**

```
-r requirements.txt
mypy
ruff
black
pytest
datamodel-code-generator
```

The `-r requirements.txt` includes the production deps. Then adds dev-only tools:
- `mypy` for typecheck (locked: turbo typecheck runs mypy)
- `ruff` for lint (Claude's discretion: ruff over flake8 -- faster, covers isort)
- `black` for format (locked: turbo format runs Black for backend)
- `pytest` for test (locked: turbo test runs pytest)
- `datamodel-code-generator` for JSON Schema to Pydantic generation (needed by shared-types)
  </action>
  <verify>
cat apps/backend/package.json | python3 -c "import sys,json; d=json.load(sys.stdin); assert d['name']=='@indexcards/backend'; assert 'dev' in d['scripts']; assert 'uv run' in d['scripts']['build']; print('Backend package.json OK')"
cat apps/backend/.python-version | grep -q '3.12' && echo ".python-version OK"
grep -q 'mypy' apps/backend/requirements-dev.txt && grep -q 'ruff' apps/backend/requirements-dev.txt && echo "requirements-dev.txt OK"
  </verify>
  <done>Backend has thin package.json with all turbo-compatible scripts delegating to uv run, .python-version pinning 3.12, and requirements-dev.txt with mypy/ruff/black/pytest/datamodel-code-generator.</done>
</task>

<task type="auto">
  <name>Task 2: Update frontend package.json with workspace name, scripts, and shared-types dep</name>
  <files>
    apps/frontend/package.json
  </files>
  <action>
Update the existing `apps/frontend/package.json` (moved from `frontend/package.json` in Plan 01).

**Changes to make:**

1. **Rename:** Change `"name": "frontend"` to `"name": "@indexcards/frontend"` -- enables turbo filtering by `--filter=@indexcards/frontend` or `--filter=frontend`.

2. **Add missing scripts** that turbo expects:
   - `"typecheck": "tsc --noEmit"` -- for `turbo typecheck`
   - `"format": "npx prettier --write src/"` -- for `turbo format` (Claude's discretion: Prettier for frontend)
   - `"clean": "rm -rf dist node_modules/.cache"` -- for `turbo clean`
   - `"test": "echo 'No tests yet'"` -- placeholder so turbo test doesn't fail; vitest will be added when tests are written

3. **Update dev script** with port conflict detection:
   ```
   "dev": "node -e \"const net=require('net');const s=net.createServer();s.once('error',e=>{if(e.code==='EADDRINUSE'){console.error('\\x1b[31mERROR: Port 5173 is already in use. Stop the process using it or choose a different port.\\x1b[0m');process.exit(1)}});s.listen(5173,()=>{s.close(()=>{const{execSync}=require('child_process');try{execSync('npx vite',{stdio:'inherit'})}catch(e){process.exit(e.status||1)}})})\"",
   ```

4. **Add workspace dependency** for shared types:
   ```json
   "dependencies": {
     "@indexcards/shared-types": "*",
     // ... existing deps
   }
   ```

5. **Add Prettier** to devDependencies:
   ```json
   "devDependencies": {
     "prettier": "^3.5.0",
     // ... existing deps
   }
   ```

Keep all existing dependencies, scripts (`build`, `lint`, `preview`), and devDependencies intact. Only add/modify the items listed above.
  </action>
  <verify>
cat apps/frontend/package.json | python3 -c "import sys,json; d=json.load(sys.stdin); assert d['name']=='@indexcards/frontend'; assert 'typecheck' in d['scripts']; assert '@indexcards/shared-types' in d.get('dependencies',{}); print('Frontend package.json OK')"
  </verify>
  <done>Frontend package.json renamed to @indexcards/frontend, has all turbo-compatible scripts (dev with port check, build, test, lint, typecheck, format, clean), includes @indexcards/shared-types workspace dependency, and Prettier added to devDependencies.</done>
</task>

<task type="auto">
  <name>Task 3: Create root setup script for Python venv auto-management</name>
  <files>
    scripts/setup.mjs
  </files>
  <action>
Create `scripts/setup.mjs` at repo root. This is the script invoked by `npm run setup` (defined in root package.json from Plan 01).

Per locked decision: "Python venv auto-managed: root setup script creates venv and installs requirements automatically."

```javascript
// scripts/setup.mjs
import { execSync, spawnSync } from 'child_process'
import { existsSync } from 'fs'
import { resolve } from 'path'

const ROOT = resolve(import.meta.dirname, '..')
const BACKEND = resolve(ROOT, 'apps/backend')

function run(cmd, opts = {}) {
  console.log(`  > ${cmd}`)
  execSync(cmd, { stdio: 'inherit', ...opts })
}

function checkCommand(cmd) {
  const result = spawnSync(cmd, ['--version'], { stdio: 'pipe' })
  return result.status === 0
}

console.log('\n=== Indexcards OCR - Project Setup ===\n')

// Step 1: Check uv is installed
console.log('1. Checking uv (Python manager)...')
if (!checkCommand('uv')) {
  console.error('\x1b[31muv is not installed.\x1b[0m')
  console.error('Install it from: https://docs.astral.sh/uv/getting-started/installation/')
  console.error('  curl -LsSf https://astral.sh/uv/install.sh | sh')
  process.exit(1)
}
console.log('   uv found.\n')

// Step 2: Create Python venv and install deps
console.log('2. Setting up Python backend...')
if (!existsSync(resolve(BACKEND, '.venv'))) {
  console.log('   Creating virtual environment...')
  run('uv venv', { cwd: BACKEND })
} else {
  console.log('   Virtual environment already exists.')
}

console.log('   Installing Python dependencies...')
run('uv pip install -r requirements.txt', { cwd: BACKEND })

if (existsSync(resolve(BACKEND, 'requirements-dev.txt'))) {
  console.log('   Installing Python dev dependencies...')
  run('uv pip install -r requirements-dev.txt', { cwd: BACKEND })
}
console.log('')

// Step 3: Install npm workspaces
console.log('3. Installing npm workspace dependencies...')
run('npm install', { cwd: ROOT })
console.log('')

// Step 4: Verify .env exists
console.log('4. Checking .env file...')
if (!existsSync(resolve(ROOT, '.env'))) {
  console.warn('\x1b[33mWARNING: No .env file found at project root.\x1b[0m')
  console.warn('Copy .env.example to .env and fill in your OPENROUTER_API_KEY:')
  console.warn('  cp .env.example .env')
} else {
  console.log('   .env file found.')
}

console.log('\n=== Setup complete! ===')
console.log('')
console.log('Available commands:')
console.log('  npm run dev        - Start frontend + backend')
console.log('  npm run build      - Build frontend + lint/typecheck backend')
console.log('  npm run test       - Run all tests')
console.log('  npm run lint       - Lint all packages')
console.log('  npm run typecheck  - Typecheck all packages')
console.log('  npm run format     - Format all packages')
console.log('')
```

Key behaviors:
- Checks `uv` is installed, exits with clear error if not
- Creates `.venv` in `apps/backend/` if it doesn't exist
- Installs both production and dev Python dependencies
- Runs `npm install` for workspace dependency resolution
- Warns if `.env` is missing
- Prints available commands at the end
  </action>
  <verify>
node -c scripts/setup.mjs 2>/dev/null; node --check scripts/setup.mjs 2>/dev/null || node -e "import('file:///$(pwd)/scripts/setup.mjs').catch(()=>{})" 2>/dev/null; test -f scripts/setup.mjs && echo "Setup script exists OK"
  </verify>
  <done>Root setup script at scripts/setup.mjs checks uv, creates Python venv, installs all dependencies, runs npm install, and provides clear guidance. Invocable via npm run setup.</done>
</task>

</tasks>

<verification>
After all 3 tasks:

1. **Backend workspace recognized by turbo:**
   ```
   cat apps/backend/package.json | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['name'])"
   # Should output: @indexcards/backend
   ```

2. **Frontend workspace recognized by turbo:**
   ```
   cat apps/frontend/package.json | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['name'])"
   # Should output: @indexcards/frontend
   ```

3. **All turbo scripts have corresponding package scripts:**
   For each turbo task (dev, build, test, lint, typecheck, format, clean), verify both apps/backend/package.json and apps/frontend/package.json have matching script entries.

4. **Setup script is syntactically valid:**
   ```
   node --input-type=module -e "import './scripts/setup.mjs'" 2>&1 || echo "Check manually"
   ```

5. **Port conflict detection works:**
   Start a dummy server on 8000, run the backend dev script, confirm it errors with a clear message.
</verification>

<success_criteria>
- apps/backend/package.json is a thin npm wrapper with all turbo task scripts delegating to uv run
- apps/backend/.python-version pins Python 3.12 for uv
- apps/backend/requirements-dev.txt adds mypy, ruff, black, pytest, datamodel-code-generator
- apps/frontend/package.json renamed to @indexcards/frontend with all turbo task scripts
- apps/frontend/package.json includes @indexcards/shared-types workspace dependency
- scripts/setup.mjs creates venv, installs deps, and provides clear feedback
- Port conflict detection in both dev scripts
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-add-turbo/02.1-02-SUMMARY.md`
</output>
