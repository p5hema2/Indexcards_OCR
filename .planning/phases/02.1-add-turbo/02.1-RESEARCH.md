# Phase 02.1: Add Turbo - Research

**Researched:** 2026-02-21
**Domain:** Turborepo monorepo setup, Python/Node hybrid workspace, cross-language type generation
**Confidence:** HIGH (core Turborepo) / MEDIUM (Python integration patterns)

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Dev Workflow
- `turbo dev` starts both Vite (frontend) and uvicorn (backend) in parallel by default
- Allow filtering: `turbo dev --filter=frontend` or `turbo dev --filter=backend` to run individually
- Single shared `.env` file at repo root, both packages read from it
- Per-package installs with root-level orchestration (not hoisted node_modules)
- Backend integrates via thin `package.json` wrapper — npm scripts call pip/uvicorn under the hood
- Port conflicts: fail with a clear error message showing which port is occupied
- Python venv auto-managed: root setup script creates venv and installs requirements automatically
- `turbo build` runs Vite build (frontend) + Python typecheck/lint (backend "build" task)
- `turbo test` runs vitest (frontend) + pytest (backend) in parallel
- `turbo typecheck` runs tsc (frontend) + mypy/pyright (backend)

#### Package Structure
- Top-level layout: `apps/frontend`, `apps/backend`, `packages/`
- Shared types package: `packages/shared-types` with API request/response contracts
- Cross-language type generation: single source of truth (e.g., JSON Schema) generates both TypeScript interfaces and Pydantic models
- Legacy files (indexcard_ocr.py, data/, etc.) move to `apps/legacy/`

#### Script Orchestration
- Local caching only (`.turbo/`), no remote cache
- Full command set: `dev`, `build`, `test`, `lint`, `typecheck`, `clean`, `format`, `install`/`setup`
- `turbo lint` runs ESLint (frontend) + ruff/flake8 (backend) in parallel
- Strict task dependency pipeline: typecheck before build, lint independent, test after build
- `turbo format` runs Prettier (frontend) + Black (backend)

#### Migration Approach
- Preserve git history using `git mv` when moving frontend/ and backend/ into apps/
- Single atomic commit for the entire restructure
- Scan repo for hardcoded path references before migration (user unsure if CI/Docker/scripts exist)
- Root-level legacy files move to `apps/legacy/`

### Claude's Discretion
- Dev output formatting (use Turbo's built-in package-prefixed output)
- Clean command scope (cache vs. full wipe)
- Additional shared packages beyond types (e.g., shared ESLint/Prettier config)
- Python version manager choice (pick one compatible with future exe/dmg/Docker packaging)
- Exact task dependency graph design

### Deferred Ideas (OUT OF SCOPE)
- Remote caching (Vercel Remote Cache) — add later if CI gets slow
- Docker packaging — Phase 5 scope
- exe/dmg bundling — Phase 5 scope
</user_constraints>

---

## Summary

Turborepo 2.8.10 is already installed globally on this machine. The current repo has a flat `frontend/` + `backend/` structure with no CI, no Dockerfiles, and no shell scripts — making the migration path straightforward. The only hardcoded path references to `frontend/` and `backend/` found in the codebase exist only in `.planning/` documentation files, not in any runtime code.

Turborepo's hybrid Python/Node support is well-established: the pattern is to add a thin `package.json` to the Python backend directory that wraps Python commands as npm scripts. Turborepo cares only that a workspace has a `package.json` with `name` and `scripts` — it does not care that the scripts invoke Python instead of Node. This pattern is confirmed by official Turborepo community discussions and a known proof-of-concept repository (`sinanbekar/monorepo-turborepo-python`).

The cross-language type generation requirement (JSON Schema → TypeScript + Pydantic) is the most novel piece. The recommended tool is `datamodel-code-generator` (Python, generates Pydantic models from JSON Schema) combined with `json-schema-to-typescript` (npm, generates TypeScript interfaces from JSON Schema). The existing Pydantic models in `backend/app/models/schemas.py` represent the authoritative API contract and should become the source for JSON Schema generation via `pydantic.model_json_schema()`.

**Primary recommendation:** Set up npm workspaces at root + turbo.json pipeline, migrate `frontend/` → `apps/frontend` and `backend/` → `apps/backend` via `git mv`, create a thin `backend/package.json` wrapper, add `packages/shared-types` with codegen scripts, and pick `uv` as the Python version/environment manager.

---

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| turbo | 2.8.10 (already installed) | Task orchestration, caching, parallel execution | Already present on machine; latest stable release |
| npm workspaces | npm 11.6.2 | Workspace discovery, per-package node_modules | Already using npm; built-in, no extra install |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| uv | latest (~0.5.x) | Python version management + venv creation | Best 2025 choice for cross-platform, Docker/PyInstaller compatible |
| datamodel-code-generator | latest | Generate Pydantic models from JSON Schema | Source of truth: JSON Schema → Pydantic |
| json-schema-to-typescript | latest | Generate TypeScript interfaces from JSON Schema | Source of truth: JSON Schema → TypeScript |
| ruff | latest | Python linter (replaces flake8) | Fastest Python linter; covers flake8 + isort |
| black | latest | Python formatter | Stable, zero-config Python formatter |
| mypy | latest | Python static type checker | Most established Python typechecker |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| uv | pyenv | pyenv compiles from source (slow), no package management; uv is faster and covers both version management and pip replacement |
| uv | mise | mise manages multiple language runtimes, overkill for this project; uv is Python-focused and simpler |
| json-schema-to-typescript | quicktype | quicktype is more powerful but heavier; json-schema-to-typescript is purpose-built for JSON Schema → TS |
| ruff | flake8 | ruff is 10-100x faster than flake8, written in Rust, covers isort too; decision is "Claude's discretion" |

**Installation:**
```bash
# Root-level (turbo + workspace config)
npm install turbo --save-dev

# Python tooling (on developer machine)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Type generation tools (in packages/shared-types)
npm install --save-dev json-schema-to-typescript

# Python codegen (add to backend/requirements-dev.txt)
# datamodel-code-generator
```

---

## Architecture Patterns

### Recommended Project Structure

```
Indexcards_OCR/                  ← repo root
├── package.json                 ← root: "private": true, workspaces, turbo scripts
├── turbo.json                   ← pipeline config
├── .env                         ← single shared .env (OPENROUTER_API_KEY, etc.)
├── .env.example                 ← checked in, documents required vars
├── .turbo/                      ← local cache (gitignored)
├── apps/
│   ├── frontend/                ← moved from frontend/ via git mv
│   │   ├── package.json         ← name: "@indexcards/frontend"
│   │   ├── vite.config.ts
│   │   └── src/
│   ├── backend/                 ← moved from backend/ via git mv
│   │   ├── package.json         ← thin wrapper: name "@indexcards/backend"
│   │   ├── requirements.txt
│   │   ├── requirements-dev.txt
│   │   ├── .python-version      ← declares Python version for uv
│   │   └── app/
│   └── legacy/                  ← root-level Python legacy files
│       ├── indexcard_ocr.py
│       ├── config.py
│       ├── requirements.txt
│       └── tests/
└── packages/
    └── shared-types/            ← JSON Schema + codegen scripts
        ├── package.json         ← name: "@indexcards/shared-types"
        ├── schemas/             ← JSON Schema source files (.json)
        ├── generated/
        │   ├── ts/              ← generated TypeScript interfaces
        │   └── py/              ← generated Pydantic models
        └── scripts/
            └── generate.sh      ← runs json-schema-to-typescript + datamodel-codegen
```

### Pattern 1: Root package.json with npm Workspaces

**What:** The repo root declares all workspace locations. Turborepo uses this to discover packages.
**When to use:** Always — this is the foundation.

```json
// package.json (root)
{
  "name": "indexcards-ocr",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build",
    "test": "turbo run test",
    "lint": "turbo run lint",
    "typecheck": "turbo run typecheck",
    "format": "turbo run format",
    "clean": "turbo run clean",
    "setup": "node scripts/setup.mjs"
  },
  "devDependencies": {
    "turbo": "^2.8.10"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "packageManager": "npm@11.6.2"
}
```

### Pattern 2: turbo.json Pipeline

**What:** Defines the task graph — which tasks depend on which, what to cache, what is persistent.
**When to use:** All task orchestration goes here.

```json
// turbo.json
{
  "$schema": "https://turborepo.dev/schema.json",
  "ui": "stream",
  "tasks": {
    "dev": {
      "cache": false,
      "persistent": true,
      "dependsOn": []
    },
    "build": {
      "dependsOn": ["^build", "typecheck"],
      "outputs": ["dist/**", ".next/**"]
    },
    "typecheck": {
      "dependsOn": ["^build"],
      "outputs": []
    },
    "test": {
      "dependsOn": ["build"],
      "outputs": ["coverage/**"],
      "inputs": ["src/**", "tests/**", "*.config.*"]
    },
    "lint": {
      "outputs": []
    },
    "format": {
      "cache": false,
      "outputs": []
    },
    "clean": {
      "cache": false
    },
    "generate": {
      "outputs": ["generated/**"]
    }
  }
}
```

**Key notes on task dependency graph:**
- `"persistent": true` on `dev` — required so Turborepo knows it won't exit; allows running multiple persistent tasks in parallel
- `"^build"` syntax means "build all workspace dependencies first" — critical for `packages/shared-types`
- `typecheck` before `build` (locked decision) — implement via `"dependsOn": ["typecheck"]` on build
- `lint` has no `dependsOn` — runs fully in parallel (locked decision)
- `test` after `build` — implement via `"dependsOn": ["build"]`

### Pattern 3: Backend thin package.json wrapper

**What:** A `package.json` in `apps/backend/` that is recognized as a workspace but delegates all execution to Python.
**When to use:** Every npm task that should invoke Python tooling.

```json
// apps/backend/package.json
{
  "name": "@indexcards/backend",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "uv run uvicorn app.main:app --reload --host 0.0.0.0 --port 8000",
    "build": "uv run mypy app/ && uv run ruff check app/",
    "typecheck": "uv run mypy app/",
    "test": "uv run pytest tests/ -v",
    "lint": "uv run ruff check app/",
    "format": "uv run black app/ && uv run ruff check --fix app/",
    "clean": "find . -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null; rm -rf .mypy_cache .ruff_cache; exit 0"
  }
}
```

**Note:** `uv run` automatically uses the project's virtual environment. It reads `.python-version` or `pyproject.toml` for the Python version. This is the key advantage of uv over `python -m` — no venv activation needed.

### Pattern 4: .env file — single root, both packages read it

**What:** A single `.env` at repo root. Backend reads it via `pydantic-settings`. Frontend reads it via Vite's built-in env loading (relative to `root` of the Vite project — must configure `envDir`).
**When to use:** This is a locked decision.

```typescript
// apps/frontend/vite.config.ts — add envDir pointing to repo root
import { defineConfig } from 'vite'
import path from 'path'

export default defineConfig({
  envDir: path.resolve(__dirname, '../..'),  // ← points to repo root
  // ... rest of config
})
```

The backend already reads `.env` via `pydantic-settings` `env_file = ".env"` — this needs to be adjusted to a path relative to the repo root, or the `uv run` command needs to be invoked from the backend directory (which it will be, since Turborepo runs scripts from the package directory).

**Important:** When Turborepo runs a task in `apps/backend/`, the CWD is `apps/backend/`. The `env_file = ".env"` in `pydantic-settings` will look for `.env` in `apps/backend/`. Options:
1. Add a `apps/backend/.env` that re-exports from root (symlink or copy — not ideal)
2. Change `env_file` to `"../../.env"` (relative to backend CWD)
3. Use `uv run --env-file ../../.env uvicorn ...` (cleanest)

**Recommendation (Claude's discretion):** Change `env_file` in `backend/app/core/config.py` to accept both root and local `.env` via a list: `env_file = ("../../.env", ".env")` — pydantic-settings accepts a tuple/list.

### Pattern 5: Cross-language Type Generation

**What:** JSON Schema files in `packages/shared-types/schemas/` are the single source of truth. A `generate` script produces both TypeScript interfaces and Pydantic models.
**When to use:** Whenever a new API request/response shape is defined.

The existing Pydantic models in `backend/app/models/schemas.py` have ~14 model classes. These should be converted to JSON Schema as the source of truth (or alternatively, Pydantic can generate JSON Schema from itself using `model.model_json_schema()`).

**Recommended flow:**
```
JSON Schema files
    ↓ json-schema-to-typescript    → packages/shared-types/generated/ts/*.ts
    ↓ datamodel-code-generator     → packages/shared-types/generated/py/*.py
```

The generated Pydantic models then get imported into `apps/backend/`, and the generated TypeScript types get imported into `apps/frontend/` via workspace dependency:
```json
// apps/frontend/package.json
{
  "dependencies": {
    "@indexcards/shared-types": "*"
  }
}
```

### Pattern 6: Python Version Management with uv

**What:** `uv` manages Python versions, virtual environments, and package installation.
**When to use:** This is Claude's discretion — recommendation is `uv`.

```bash
# Root setup script (scripts/setup.mjs or setup.sh)
# Installs uv if not present, creates venv, installs requirements
curl -LsSf https://astral.sh/uv/install.sh | sh
uv venv apps/backend/.venv --python 3.12
uv pip install -r apps/backend/requirements.txt
uv pip install -r apps/backend/requirements-dev.txt
```

A `.python-version` file in `apps/backend/` pins the Python version for uv.

**Why uv over alternatives:**
- Cross-platform (macOS, Windows, Linux) — matches future exe/dmg/Docker requirement
- Compatible with PyInstaller for exe packaging (Phase 5)
- Compatible with Docker (well-documented uv Docker patterns exist)
- Replaces pip, venv, pyenv in one tool
- 80x faster than `python -m venv`
- Already the de-facto standard in 2025 Python tooling

### Pattern 7: git mv Migration

**What:** Move files while preserving git history.
**When to use:** One-time migration step in Phase 02.1.

```bash
# Step 1: Create new directory structure
mkdir -p apps/frontend apps/backend apps/legacy packages/shared-types

# Step 2: Move frontend
git mv frontend/* apps/frontend/
git mv frontend/.* apps/frontend/ 2>/dev/null || true

# Step 3: Move backend
git mv backend/* apps/backend/
git mv backend/.* apps/backend/ 2>/dev/null || true

# Step 4: Move legacy root files
git mv indexcard_ocr.py config.py requirements.txt apps/legacy/
git mv tests/ apps/legacy/

# Step 5: Single atomic commit
git commit -m "refactor: migrate to turborepo monorepo (apps/ + packages/)"
```

**Important:** `git mv` preserves history for `git log --follow`. Plain `mv` followed by `git add` does NOT preserve history.

### Anti-Patterns to Avoid

- **Hoisted node_modules at root:** The decision is "per-package installs with root-level orchestration." Do not use `--legacy-peer-deps` flags or npm v6-style flat installs. npm workspaces with per-package installs is the default in npm 7+.
- **Global env vars not declared in turbo.json:** Turborepo caches tasks by default. If `OPENROUTER_API_KEY` changes but is not listed in `globalEnv`, the cache will incorrectly replay old results. Add sensitive env vars to `passThroughEnv` (passes to task but doesn't bust cache) or `env` (busts cache on change). For API keys that change the output, use `env`.
- **Non-persistent dev tasks:** A `dev` task that starts a long-running server must have `"persistent": true`. Otherwise, Turborepo may kill it prematurely or other tasks that depend on it will deadlock.
- **Depending on a persistent task:** Per Turborepo docs, `"A persistent task cannot be depended on."` The `dev` task should have `"dependsOn": []` and no other task should list it as a dependency.
- **Committing `.turbo/cache`:** Add `.turbo` to `.gitignore`. Only the config file `.turbo/config.json` (remote cache config) is meaningful to commit; the cache directory is local only.
- **Running uvicorn from repo root instead of backend directory:** pydantic-settings path resolution and FastAPI's relative imports depend on running from `apps/backend/`. Turborepo runs tasks from the package directory by default — this is correct behavior.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Parallel process management | Custom shell script with `&` and `wait` | `turbo run dev` with `persistent: true` | Turborepo handles prefixed output, ctrl-c handling, process lifecycle |
| Cross-language type sync | Manual copy-paste | JSON Schema + codegen (`datamodel-code-generator` + `json-schema-to-typescript`) | Drift is inevitable; regeneration is instant |
| Python version pinning | Comments in README | `.python-version` file + uv | uv reads this automatically; reproducible across machines |
| Task ordering | Makefile chains | `turbo.json` `dependsOn` | Turbo handles parallelism, caching, error propagation |
| venv setup | Bash script with `if [ -d .venv ]` guards | `uv sync` / `uv venv` | Handles Python version download, venv creation, and install atomically |

**Key insight:** Turborepo's value is not just parallelism — it's the combination of task graph + caching + consistent output formatting. Rolling custom solutions defeats the caching benefits.

---

## Common Pitfalls

### Pitfall 1: pydantic-settings .env path resolution after directory restructure

**What goes wrong:** After moving `backend/` to `apps/backend/`, the `env_file = ".env"` in `config.py` looks for `.env` relative to the CWD at runtime. Since uvicorn is invoked from `apps/backend/`, it finds no `.env` there (it's at repo root), so all settings fall back to defaults (empty API key).

**Why it happens:** pydantic-settings resolves `env_file` relative to the process CWD, not the file location.

**How to avoid:** Update `backend/app/core/config.py`:
```python
class Config:
    env_file = ("../../.env", ".env")  # checks root first, then local
    case_sensitive = True
```
Or pass `--env-file ../../.env` to the `uv run` command in `package.json`.

**Warning signs:** `settings.OPENROUTER_API_KEY` is empty string after migration.

### Pitfall 2: Frontend vite.config.ts can't find root .env

**What goes wrong:** Vite's default `envDir` is the project root (`apps/frontend/`), not the repo root. `VITE_*` variables defined in `/.env` at repo root are invisible to the frontend.

**Why it happens:** Vite resolves `envDir` relative to the Vite config file location.

**How to avoid:** Add `envDir: path.resolve(__dirname, '../..')` to `apps/frontend/vite.config.ts`. Requires `import path from 'path'` and `@types/node` (already in devDependencies).

**Warning signs:** `import.meta.env.VITE_*` is `undefined` at runtime.

### Pitfall 3: npm workspaces installs backend node_modules into frontend

**What goes wrong:** npm workspaces may hoist packages from `apps/backend/package.json` into the root `node_modules`. Since the backend package.json has no real npm dependencies (only scripts), this is harmless — but if `devDependencies` are added to backend, they may conflict.

**Why it happens:** npm workspaces hoists by default (unlike pnpm which isolates by default).

**How to avoid:** Keep `apps/backend/package.json` dependency-free (scripts only). All Python dependencies stay in `requirements.txt`, managed by uv.

**Warning signs:** Unexpected packages appearing in root `node_modules`.

### Pitfall 4: git mv fails for hidden dotfiles

**What goes wrong:** `git mv frontend/* apps/frontend/` does not move hidden files (`.eslintrc`, `.prettierrc`, etc.) because shell glob `*` skips dotfiles.

**Why it happens:** POSIX shell behavior — `*` does not match files starting with `.`.

**How to avoid:** Explicitly run a second `git mv frontend/.* apps/frontend/` (with `|| true` to suppress error when no dotfiles match). Or use `git mv -k frontend/.[!.]* apps/frontend/` to skip `..`.

**Warning signs:** Missing config files after migration.

### Pitfall 5: Turborepo caching env vars

**What goes wrong:** `OPENROUTER_API_KEY` is not declared in `turbo.json` env config. Changing the key does not bust the cache. Cached results from old runs are replayed.

**Why it happens:** Turborepo's strict mode requires explicit env var declarations for cache invalidation.

**How to avoid:** In `turbo.json`, add task-level env config for tasks that use the API key:
```json
{
  "tasks": {
    "test": {
      "env": ["OPENROUTER_API_KEY"]
    }
  }
}
```
For the API key specifically, since it's an auth credential (not a content variable), use `passThroughEnv` if you want it available in the task without busting the cache hash.

**Warning signs:** Test tasks return cached results even when the API key changes.

### Pitfall 6: Persistent tasks blocking CI / test runs

**What goes wrong:** If `test` depends on `dev` (or vice versa), the test suite hangs forever waiting for the dev server to exit.

**Why it happens:** Turborepo enforces that no task can depend on a persistent task. It will error at configuration time.

**How to avoid:** Keep `dev` completely isolated with `"dependsOn": []`. Tests depend on `build`, not on `dev`.

**Warning signs:** `error: A task with "persistent: true" cannot be depended on` in turbo output.

---

## Code Examples

Verified patterns from official sources and confirmed working patterns:

### Root package.json with workspaces (verified)
```json
// Source: turborepo.dev/docs/crafting-your-repository/structuring-a-repository
{
  "name": "indexcards-ocr",
  "private": true,
  "workspaces": ["apps/*", "packages/*"],
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build"
  },
  "devDependencies": {
    "turbo": "^2.8.10"
  },
  "packageManager": "npm@11.6.2"
}
```

### turbo.json — complete pipeline for this project
```json
// Source: turborepo.dev/docs/crafting-your-repository/configuring-tasks
{
  "$schema": "https://turborepo.dev/schema.json",
  "ui": "stream",
  "globalEnv": ["NODE_ENV"],
  "globalPassThroughEnv": ["OPENROUTER_API_KEY"],
  "tasks": {
    "dev": {
      "cache": false,
      "persistent": true,
      "dependsOn": []
    },
    "build": {
      "dependsOn": ["^build", "typecheck"],
      "outputs": ["dist/**"]
    },
    "typecheck": {
      "dependsOn": ["^build"],
      "outputs": []
    },
    "test": {
      "dependsOn": ["build"],
      "outputs": ["coverage/**"],
      "inputs": ["src/**", "tests/**", "test_*.py", "*.config.*"]
    },
    "lint": {
      "outputs": [],
      "inputs": ["src/**", "app/**", "*.config.*"]
    },
    "format": {
      "cache": false,
      "outputs": []
    },
    "clean": {
      "cache": false
    },
    "generate": {
      "outputs": ["generated/**"],
      "inputs": ["schemas/**"]
    }
  }
}
```

### Backend thin package.json (complete)
```json
// apps/backend/package.json
{
  "name": "@indexcards/backend",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "uv run uvicorn app.main:app --reload --host 0.0.0.0 --port 8000",
    "build": "uv run ruff check app/ && uv run mypy app/",
    "typecheck": "uv run mypy app/",
    "test": "uv run pytest tests/ -v --tb=short",
    "lint": "uv run ruff check app/",
    "format": "uv run black app/ && uv run ruff check --fix app/",
    "clean": "node -e \"require('fs').rmSync('.mypy_cache', {recursive:true,force:true}); require('fs').rmSync('.ruff_cache', {recursive:true,force:true});\""
  }
}
```

### shared-types package.json
```json
// packages/shared-types/package.json
{
  "name": "@indexcards/shared-types",
  "version": "0.0.0",
  "private": true,
  "exports": {
    ".": {
      "types": "./generated/ts/index.ts",
      "default": "./generated/ts/index.ts"
    }
  },
  "scripts": {
    "generate": "node scripts/generate.mjs",
    "build": "npm run generate"
  },
  "devDependencies": {
    "json-schema-to-typescript": "latest"
  }
}
```

### frontend package.json updates
```json
// apps/frontend/package.json changes
{
  "name": "@indexcards/frontend",
  "dependencies": {
    "@indexcards/shared-types": "*",
    // ... existing deps
  }
}
```

### Filter usage examples
```bash
# Run only frontend dev
turbo dev --filter=@indexcards/frontend

# Run only backend dev
turbo dev --filter=@indexcards/backend

# Run tests only for backend
turbo test --filter=@indexcards/backend

# Build everything
turbo build
```

### Filtering by app name (short form works too)
```bash
turbo dev --filter=frontend   # matches @indexcards/frontend
turbo dev --filter=backend    # matches @indexcards/backend
```
Note: `--filter` matches on the `name` field in `package.json`. Using `@indexcards/frontend` is the unambiguous form; the short `frontend` form also works but may be ambiguous in larger repos.

### uv setup script (root-level, Node-based for cross-platform)
```javascript
// scripts/setup.mjs
import { execSync, spawnSync } from 'child_process'
import { existsSync } from 'fs'

// Check uv is installed
const uvResult = spawnSync('uv', ['--version'])
if (uvResult.status !== 0) {
  console.error('uv not found. Install from: https://docs.astral.sh/uv/getting-started/installation/')
  process.exit(1)
}

// Create venv and install deps for backend
console.log('Setting up Python backend...')
execSync('uv venv', { cwd: 'apps/backend', stdio: 'inherit' })
execSync('uv pip install -r requirements.txt', { cwd: 'apps/backend', stdio: 'inherit' })
if (existsSync('apps/backend/requirements-dev.txt')) {
  execSync('uv pip install -r requirements-dev.txt', { cwd: 'apps/backend', stdio: 'inherit' })
}

// Install npm workspaces
execSync('npm install', { stdio: 'inherit' })
console.log('Setup complete.')
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `concurrently` / `npm-run-all` for parallel tasks | Turborepo `turbo run dev` with `persistent: true` | Turbo 1.x → 2.x | Caching, prefixed output, proper task graph |
| pyenv for Python version management | uv | 2024-2025 | Replaces pip + pyenv + venv; dramatically faster |
| flake8 + isort for Python linting | ruff | 2023-2025 | 10-100x faster; single tool |
| Manual TypeScript tsconfig per app | Shared `@repo/typescript-config` package | Turbo 2.x era | Consistent config, caching benefits |
| `.env` per package | Single root `.env` | — | Fewer points of divergence |
| `turbo.json` v1 `pipeline` key | `turbo.json` v2 `tasks` key | Turbo 2.0 | `pipeline` is deprecated; `tasks` is the current key |

**Deprecated/outdated:**
- `pipeline` key in turbo.json: replaced by `tasks`. Turbo 2.x removed the old `pipeline` key.
- npm hoisting as default: pnpm is more strict by default; npm workspaces still hoists but workspace packages are isolated.
- Turborepo 1.x concepts like `--stream` flag: now `"ui": "stream"` in turbo.json is the config approach.

---

## Open Questions

1. **Port conflict detection — how to implement "fail with clear error"**
   - What we know: Turborepo itself has no built-in port conflict detection. The `dev` scripts in package.json run uvicorn and Vite directly.
   - What's unclear: The user wants a clear error when a port is occupied. Neither uvicorn nor Vite produce particularly friendly error messages on port conflict out of the box.
   - Recommendation: Wrap each dev command in a small port-check script or use the `--port 0` approach. A simple pre-flight check in the dev npm script can do `lsof -ti:8000 | head -1` and exit with a message. This is low-effort and satisfies the requirement without a library.

2. **pydantic-settings .env path — root or local?**
   - What we know: Turborepo runs tasks from the package directory (`apps/backend/`). The root `.env` is at `../../.env` relative to that CWD.
   - What's unclear: The cleanest approach — change `env_file` in Python code, or change the npm script invocation.
   - Recommendation: Use `env_file = ("../../.env", ".env")` in `config.py`. The tuple form lets pydantic-settings check the root first, then fall back to a local `.env` if present. This keeps the npm scripts clean.

3. **Clean command scope — cache only, or full wipe?**
   - What we know: This is Claude's discretion. Turborepo's local cache is in `.turbo/cache`. Python generates `__pycache__`, `.mypy_cache`, `.ruff_cache`. Frontend generates `dist/`, `node_modules/.cache/`.
   - Recommendation: Two-tier clean: (a) `turbo clean` clears build outputs and Python caches per-package; (b) `turbo clean --cache` nukes `.turbo/cache` at root level. Implement clean in each package's `package.json` as above.

4. **shared-types as build dependency or source dependency?**
   - What we know: TypeScript shared packages can be either "just-in-time" (compiled on-demand by consuming package) or pre-compiled with an `exports` field. For an internal workspace, just-in-time is simpler.
   - Recommendation: Keep `packages/shared-types` as source-only (TypeScript, no build step needed for the frontend consumer). The frontend's tsconfig `paths` or Vite's `resolve.alias` can point directly to the generated TS files. This avoids a build step for the shared-types package while still enabling IDE go-to-definition.

5. **Existing Pydantic models — migrate to JSON Schema source of truth, or generate from Pydantic?**
   - What we know: The backend has 14 Pydantic models in `schemas.py`. These are already the de-facto source of truth. Pydantic v2 can generate JSON Schema via `model_json_schema()`.
   - Recommendation: Generate JSON Schema from the existing Pydantic models as the bootstrap step, then commit those schemas to `packages/shared-types/schemas/`. Going forward, edit the JSON Schema files directly (source of truth), and regenerate both Python models and TypeScript types from them. This is a one-time migration step but aligns with the locked decision.

---

## Repo Scan Results

**Hardcoded `frontend/` or `backend/` references found in runtime code:** NONE

The grep scan found references only in `.planning/` documentation files. No runtime Python, TypeScript, shell scripts, Makefile, Dockerfile, or CI configs reference the old `frontend/` or `backend/` paths. Migration risk is LOW.

**No CI/CD files found** (no `.github/workflows/`, no `Dockerfile`, no `docker-compose.yml`). The migration is purely local.

**Existing `.env.example`** contains only `OPENROUTER_API_KEY=your_api_key_here`. The single-env strategy maps cleanly.

---

## Sources

### Primary (HIGH confidence)
- `https://turborepo.dev/docs/crafting-your-repository/structuring-a-repository` — workspace structure, apps/packages split
- `https://turborepo.dev/docs/crafting-your-repository/configuring-tasks` — turbo.json task pipeline, dependsOn/outputs/inputs/cache/persistent
- `https://turborepo.dev/docs/crafting-your-repository/running-tasks` — --filter usage, multiple task execution
- `https://turborepo.dev/docs/crafting-your-repository/managing-dependencies` — root vs package deps, internal packages
- `https://turborepo.dev/docs/crafting-your-repository/using-environment-variables` — globalEnv, env, passThroughEnv, strict mode
- `https://turborepo.dev/docs/reference/configuration` — persistent, cache, dependsOn options reference
- `https://turborepo.dev/docs/guides/tools/typescript` — shared tsconfig package, internal packages
- `https://turborepo.dev/blog/2-8` — Turborepo 2.8 release notes (current version)
- `https://github.com/vercel/turborepo/discussions/1077` — official confirmation of Python backend via package.json wrapper pattern
- `https://docs.astral.sh/uv/` — uv Python manager docs

### Secondary (MEDIUM confidence)
- `https://pypi.org/project/datamodel-code-generator/` — Python library for JSON Schema → Pydantic generation
- `https://github.com/koxudaxi/datamodel-code-generator` — datamodel-code-generator GitHub, verified active in 2025
- `https://github.com/sinanbekar/monorepo-turborepo-python` — POC repo for Turborepo + Python, confirms thin package.json wrapper pattern works

### Tertiary (LOW confidence)
- WebSearch results on git mv migration patterns — multiple sources agree on the `git mv` approach for within-repo restructuring

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — Turborepo 2.8.10 verified on this machine; npm 11.6.2 confirmed; official docs consulted for all key concepts
- Architecture: HIGH — patterns derived directly from official Turborepo documentation; Python wrapper pattern confirmed by official discussion thread
- Pitfalls: MEDIUM — env file path issue is derived from known pydantic-settings behavior; dotfile git mv issue is documented POSIX behavior; Turborepo caching env var issue is from official docs
- Python tooling (uv, ruff): MEDIUM — confirmed via multiple 2025 sources; uv PyInstaller compatibility confirmed; recommendation is well-supported

**Research date:** 2026-02-21
**Valid until:** 2026-03-21 (30 days — Turborepo is stable; uv moves faster but core patterns are stable)
