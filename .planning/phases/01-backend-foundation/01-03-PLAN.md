---
phase: 01-backend-foundation
plan: 03
type: execute
wave: 3
depends_on: [01-02]
files_modified:
  - backend/app/api/api_v1/endpoints/ws.py
  - backend/app/services/ws_manager.py
  - backend/app/services/ocr_engine.py
  - backend/app/api/api_v1/endpoints/batches.py
autonomous: false
requirements: [BACKEND-05, BACKEND-06]

must_haves:
  truths:
    - "WebSocket streams live progress updates (%, X/Y, ETA, card data)"
    - "A failed card is logged and moved to `_errors/` but processing continues"
    - "If a connection is dropped, the client can re-attach to the ongoing batch"
  artifacts:
    - path: "backend/app/services/ws_manager.py"
      provides: "WebSocket connection and state tracking"
    - path: "backend/app/api/api_v1/endpoints/ws.py"
      provides: "WebSocket endpoint at /api/v1/ws/task/{batch_id}"
  key_links:
    - from: "backend/app/services/ocr_engine.py"
      to: "backend/app/services/ws_manager.py"
      via: "Progress callback function"
---

<objective>
Implement real-time progress tracking via WebSockets and robust error handling to skip-on-failure and support batch resilience.

Purpose: To provide the user with immediate feedback and ensure large batches complete even if individual cards fail.
Output: Working WebSocket API with live progress and a resilient OCR execution flow.
</objective>

<execution_context>
@/Users/martinhess/.gemini/get-shit-done/workflows/execute-plan.md
@/Users/martinhess/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/1-CONTEXT.md
@.planning/phases/01-backend-foundation/1-RESEARCH.md
@.planning/phases/01-backend-foundation/01-02-SUMMARY.md
@.planning/phases/01-backend-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WebSocketManager and Progress Stream</name>
  <files>
    - backend/app/services/ws_manager.py
    - backend/app/api/api_v1/endpoints/ws.py
    - backend/app/services/ocr_engine.py
  </files>
  <action>
    Create a `WebSocketManager` to handle connections and broadcasts.
    - Implement `/api/v1/ws/task/{batch_id}` endpoint.
    - Integrate `WebSocketManager` into `OcrEngine` as a callback to broadcast progress (%, X/Y, ETA, live card results).
    - Implement "Re-attach" logic by storing the latest state of an active batch in the manager. When a client connects, they immediately receive the latest state.
    - Ensure messages are sent as JSON-serialized Pydantic models.
  </action>
  <verify>
    Use a WebSocket test client (like `websocat` or a simple JS script) to connect to a processing batch and verify the stream of updates.
  </verify>
  <done>
    Real-time progress streaming is working and supports client reconnects.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Error Handling, _errors/ folder, and Retry API</name>
  <files>
    - backend/app/services/ocr_engine.py
    - backend/app/api/api_v1/endpoints/batches.py
  </files>
  <action>
    Enhance `OcrEngine` with resilient error handling as specified in CONTEXT.md.
    - Wrap the card processing loop in a try/except that logs errors and moves the failed image to an `_errors/` subfolder within the batch directory.
    - Processing MUST continue to the next card on failure.
    - Implement `POST /api/v1/batches/{batch_id}/retry` to re-process ONLY the files in the `_errors/` folder.
    - Implement resume logic that checks the `checkpoint.json` of a batch before starting and skips already successful files.
  </action>
  <verify>
    Simulate an error (e.g., provide a corrupt image or mock a 500 error) and verify that the card is moved to `_errors/` and the batch completes successfully for other cards.
  </verify>
  <done>
    OCR engine is resilient, handles individual errors gracefully, and supports retries.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>End-to-End backend foundation for OCR processing</what-built>
  <how-to-verify>
    1. Upload a set of images via `/api/v1/upload`.
    2. Start a batch via `/api/v1/batches` with custom fields.
    3. Connect to the WebSocket at `/api/v1/ws/task/{batch_id}`.
    4. Observe real-time progress and JSON results streaming.
    5. Verify batch completes and creates the expected output directories (json, csv, _errors).
  </how-to-verify>
  <resume-signal>approved</resume-signal>
</task>

</tasks>

<verification>
Perform an end-to-end test from upload to completion, ensuring the WebSocket provides live updates and that any (simulated) failures are moved to the error folder and logged.
</verification>

<success_criteria>
- WebSocket provides accurate, real-time progress and data updates.
- Clients can reconnect to ongoing tasks without losing state.
- Individual card failures do not crash the batch processing.
- Retry endpoint successfully processes only previously failed cards.
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-03-SUMMARY.md`
</output>
