---
phase: 01-backend-foundation
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/app/services/ocr_engine.py
  - apps/backend/app/api/api_v1/endpoints/batches.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "OCR progress is broadcast to WebSocket clients in real-time during batch processing"
    - "asyncio event loop is captured in async context before entering worker thread"
    - "If OCR fails before any progress is broadcast, a 'failed' status is still sent to WebSocket clients"
  artifacts:
    - path: "apps/backend/app/services/ocr_engine.py"
      provides: "Correct event loop capture for thread-safe WS callback"
      contains: "asyncio.get_running_loop()"
    - path: "apps/backend/app/api/api_v1/endpoints/batches.py"
      provides: "Fallback failed broadcast when last_state is None"
      contains: "BatchProgress("
  key_links:
    - from: "apps/backend/app/api/api_v1/endpoints/batches.py:run_ocr_task"
      to: "apps/backend/app/services/ocr_engine.py:process_batch"
      via: "await ocr_engine.process_batch(progress_callback=ws_manager.broadcast_progress)"
      pattern: "progress_callback"
    - from: "apps/backend/app/services/ocr_engine.py:_run_batch"
      to: "apps/backend/app/services/ws_manager.py:broadcast_progress"
      via: "asyncio.run_coroutine_threadsafe(callback, loop)"
      pattern: "run_coroutine_threadsafe"
---

<objective>
Fix the WebSocket progress streaming blocker: asyncio event loop bug in ocr_engine.py and silent failure in batches.py.

Purpose: This is the BLOCKER gap from UAT test 7. WebSocket connects successfully (both direct and via Vite proxy) but receives zero messages because: (1) ocr_engine.py line 263 calls asyncio.get_event_loop() inside a worker thread (asyncio.to_thread), getting the wrong/dead loop — asyncio.run_coroutine_threadsafe() then schedules on that dead loop and progress callbacks never fire; (2) batches.py lines 59-64 check last_state which is None when no progress was ever broadcast, so the exception handler silently swallows the error and never broadcasts a "failed" status.

Output: Working WebSocket progress streaming during OCR and proper failure broadcast.
</objective>

<execution_context>
@/Users/martinhess/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martinhess/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation/01-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix asyncio event loop capture in ocr_engine.py</name>
  <files>
    apps/backend/app/services/ocr_engine.py
  </files>
  <action>
In `process_batch()` (the async method), capture the running event loop BEFORE entering the worker thread:

1. At the top of `process_batch()`, after `start_time = time.time()` (around line 251), add:
   ```python
   loop = asyncio.get_running_loop()
   ```

2. Change `_run_batch()` inner function (line 262) so it receives the loop from the closure instead of calling asyncio.get_event_loop(). Remove line 263 (`loop = asyncio.get_event_loop()`).

The corrected code pattern:
```python
async def process_batch(self, ...):
    ...
    start_time = time.time()
    loop = asyncio.get_running_loop()  # Capture in async context

    def _save_checkpoint(current_results):
        ...

    def _run_batch():
        # 'loop' is now from the closure — the correct running event loop
        res_map = {r["filename"]: r for r in results}
        ...
```

Everything else in _run_batch() stays the same — `asyncio.run_coroutine_threadsafe(callback, loop)` on line 316 will now use the correct event loop from the closure.
  </action>
  <verify>
1. Read ocr_engine.py and confirm:
   - `asyncio.get_running_loop()` is called in `process_batch()` (async context)
   - `asyncio.get_event_loop()` is NOT called anywhere in `_run_batch()` (thread context)
   - `asyncio.run_coroutine_threadsafe(callback, loop)` uses the closure variable
2. Grep for any remaining `get_event_loop` calls in the file — there should be zero.
  </verify>
  <done>
Event loop is captured correctly in async context and passed to worker thread via closure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix silent failure broadcast in batches.py</name>
  <files>
    apps/backend/app/api/api_v1/endpoints/batches.py
  </files>
  <action>
In `run_ocr_task()`, fix two locations where `last_state` may be None:

1. **Exception handler (lines 59-64)**: When `last_state` is None (no progress was ever broadcast), create a minimal BatchProgress with status='failed' and broadcast it:
```python
except Exception as e:
    logger.exception(f"Error in background OCR task for {batch_name}: {e}")
    last_state = ws_manager.batch_states.get(batch_name)
    if last_state:
        last_state.status = "failed"
        await ws_manager.broadcast_progress(batch_name, last_state)
    else:
        # No progress was ever broadcast — create minimal failed state
        from app.models.schemas import BatchProgress
        failed_state = BatchProgress(
            batch_name=batch_name,
            current=0,
            total=0,
            percentage=0.0,
            status="failed",
        )
        await ws_manager.broadcast_progress(batch_name, failed_state)
```

2. **Completion handler (lines 50-57)**: Apply the same pattern when `last_state` is None after successful completion (edge case: batch had 0 processable files):
```python
last_state = ws_manager.batch_states.get(batch_name)
if last_state:
    if cancel_event.is_set():
        last_state.status = "cancelled"
    else:
        last_state.status = "completed"
    await ws_manager.broadcast_progress(batch_name, last_state)
else:
    # Edge case: no files processed — broadcast completed/cancelled with zeroed progress
    from app.models.schemas import BatchProgress
    status = "cancelled" if cancel_event.is_set() else "completed"
    final_state = BatchProgress(
        batch_name=batch_name,
        current=0,
        total=0,
        percentage=0.0,
        status=status,
    )
    await ws_manager.broadcast_progress(batch_name, final_state)
```

Also add `BatchProgress` to the imports at the top of the file (alongside the existing `BatchResponse` import).
  </action>
  <verify>
1. Read batches.py and confirm both the success/completion and exception handlers have None guards with fallback BatchProgress creation.
2. Confirm BatchProgress is imported at the top of the file.
  </verify>
  <done>
Both completion and failure paths broadcast a status message even when no prior progress existed.
  </done>
</task>

</tasks>

<verification>
- ocr_engine.py uses `asyncio.get_running_loop()` in `process_batch` (async context), not `asyncio.get_event_loop()` in `_run_batch` (thread context)
- batches.py exception handler creates a fallback BatchProgress when last_state is None
- batches.py completion handler creates a fallback BatchProgress when last_state is None
- No `asyncio.get_event_loop()` calls remain in ocr_engine.py
</verification>

<success_criteria>
UAT test 7 (WebSocket progress streaming) unblocked: progress callbacks fire correctly during OCR processing. If OCR fails before any progress, frontend receives a "failed" status instead of hanging forever. This also unblocks UAT tests 8 (error handling) and 9 (retry).
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-07-SUMMARY.md`
</output>
